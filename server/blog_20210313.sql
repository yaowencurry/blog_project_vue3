/*
 Navicat Premium Data Transfer

 Source Server         : 哈哈哈哈哈
 Source Server Type    : MySQL
 Source Server Version : 80023
 Source Host           : 42.192.140.201:3306
 Source Schema         : blog

 Target Server Type    : MySQL
 Target Server Version : 80023
 File Encoding         : 65001

 Date: 13/03/2021 20:17:14
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for artical
-- ----------------------------
DROP TABLE IF EXISTS `artical`;
CREATE TABLE `artical` (
  `articalid` int NOT NULL AUTO_INCREMENT COMMENT '文章id',
  `title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '文章标题',
  `ctime` varchar(24) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '创建时间',
  `author` varchar(8) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '作者姓名',
  `count` int DEFAULT NULL COMMENT '字数',
  `readtimer` int DEFAULT NULL COMMENT '阅读时长',
  `desc` varchar(256) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '概述',
  `prew` int DEFAULT NULL COMMENT '阅读量',
  `comment` int DEFAULT NULL COMMENT '评论数量',
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '内容',
  `originmarkdown` longtext CHARACTER SET utf8 COLLATE utf8_general_ci COMMENT 'markdown源码',
  `type` varchar(2) DEFAULT NULL COMMENT '文章类型，1HTML，2CSS，3JS，4nodejs',
  `status` varchar(2) DEFAULT NULL COMMENT '文章状态，0草稿，1正常，2删除',
  `articalclass` varchar(2) DEFAULT NULL COMMENT '分类：1博客文章，2函数库',
  PRIMARY KEY (`articalid`)
) ENGINE=InnoDB AUTO_INCREMENT=1000080 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of artical
-- ----------------------------
BEGIN;
INSERT INTO `artical` VALUES (1000024, '前端代码风格指南 ｜ HTML、CSS、JavaScript以及Vue代码风格指南', '2021-02-08 09:03:29', '姚文', 584, 1, '尽量避免代码行超过 80 个字符。短注释应该在单行中书写，并在 <!-- 之后增加一个空格，在 <!-- 之前增加一个空格。长注释，跨越多行，应该通过 在独立的行中书写。多个属性应当分行。', 0, 0, '<p>前端代码风格整理</p>\n<h2 id=\"html\">HTML</h2>\n<ul>\n<li>请使用小写元素名 </li>\n</ul>\n<pre><code class=\"html language-html\">&lt;div&gt;&lt;/div&gt;\n</code></pre>\n<ul>\n<li>关闭所有 HTML 元素。</li>\n</ul>\n<pre><code class=\"html language-html\">&lt;section&gt;\n  &lt;p&gt;This is a paragraph.&lt;/p&gt;\n  &lt;p&gt;This is a paragraph.&lt;/p&gt;\n&lt;/section&gt;\n</code></pre>\n<ul>\n<li>关闭空的 HTML 元素。</li>\n</ul>\n<pre><code class=\"html language-html\">&lt;meta charset=\"utf-8\" /&gt;\n</code></pre>\n<ul>\n<li>使用小写属性名。 </li>\n</ul>\n<pre><code class=\"html language-html\">&lt;div class=\"menu\"&gt;\n</code></pre>\n<ul>\n<li>属性值加引号。</li>\n</ul>\n<pre><code class=\"html language-html\">&lt;table class=\"table striped\"&gt;\n</code></pre>\n<ul>\n<li>请始终对图像使用 alt 属性。当图像无法显示时该属性很重要。</li>\n</ul>\n<pre><code class=\"html language-html\">&lt;img src=\"html5.gif\" alt=\"HTML5\" style=\"width:128px;height:128px\"&gt;\n</code></pre>\n<ul>\n<li>等号两边的空格是合法的</li>\n</ul>\n<pre><code class=\"html language-html\">&lt;link rel = \"stylesheet\" href = \"styles.css\"&gt;\n</code></pre>\n<ul>\n<li>尽量避免代码行超过 80 个字符。</li>\n<li>短注释应该在单行中书写，并在 <!-- 之后增加一个空格，在 <!-- 之前增加一个空格。长注释，跨越多行，应该通过 <!-- 和 --> 在独立的行中书写。</li>\n<li>多个属性应当分行。</li>\n</ul>\n<h2 id=\"css\">CSS</h2>\n<ul>\n<li>为ID和class取通用且有意义的名字。</li>\n<li>非必要的情况下，ID和class的名称应尽量简短。</li>\n<li>非必要的情况下不要使用元素标签名和ID或class进行组合（div.nav  div#nav）。</li>\n<li>写属性值的时候尽量使用缩写。</li>\n<li>非必要的情况下 0 后面不用加单位，省略0开头小数点前面的0。。</li>\n<li>十六进制尽可能使用3个字符。</li>\n<li>缩进所有代码块的内容，它能够提高层次结构的清晰度。</li>\n<li>所有声明都要用\";\"结尾。考虑到一致性和拓展性，请在每个声明尾部都加上分号。</li>\n<li>在属性名和值之间加一个空格（可不是属性名和冒号之间噢）。</li>\n<li>每个选择器和声明都要独立新行。</li>\n<li>两个规则之间隔行。</li>\n<li>CSS书写顺序：<ul>\n<li>位置属性(position, top, right, z-index, display, float等)</li>\n<li>大小(width, height, padding, margin)</li>\n<li>文字系列(font, line-height, letter-spacing, color- text-align等)</li>\n<li>背景(background, border等)</li>\n<li>其他(animation, transition等)</li></ul></li>\n</ul>\n<h2 id=\"javascript\">JAVASCRIPT</h2>\n<ul>\n<li>使用两个空格进行缩进。</li>\n<li>除需要转义的情况外，字符串统一使用单引号。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">let name = \'curry\' // ok\nlet name = \"curry\" //aviod\n</code></pre>\n<ul>\n<li>不要定义未使用的变量。</li>\n<li>关键字后面加空格。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">if (name === \'curry\') {  }  //ok\nif(name===\'curry){ ... } //aviod\n</code></pre>\n<ul>\n<li>函数声明时括号与函数名间加空格。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">function name (arg) { ... } //ok\nfunction name(arg){ ... } //aciod\n</code></pre>\n<ul>\n<li>始终使用 === 替代 ==。(例外： obj == null 可以用来检查 null || undefined。)</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">if (name === \'curry\') //ok\nif (name == \'curry\') //aviod\n</code></pre>\n<ul>\n<li>字符串拼接操作符 (Infix operators) 之间要留空格。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">let name = \'stphen\' + name + \'!\' //ok\nlet name = \'stphen\'+name+\'!\' //aviod\n</code></pre>\n<ul>\n<li>逗号后面加空格。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">let obj = {a: 1, b: 2}//ok\nlet obj = {a: 1,b: 2}//aviod\n</code></pre>\n<ul>\n<li>else 关键字要与花括号保持在同一行。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">//ok\nif (...) {\n    ...\n} else {\n    ...\n}\n\n//aviod\nif (...) {\n    ...\n} \nelse\n{\n    ...\n}\n</code></pre>\n<ul>\n<li>多行 if 语句的的括号不能省。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">// ✓ ok\nif (options.quiet !== true) console.log(\'done\')\n// ✓ ok\nif (options.quiet !== true) {\n  console.log(\'done\')\n}\n// ✗ avoid\nif (options.quiet !== true)\n  console.log(\'done\')\n</code></pre>\n<ul>\n<li>不要丢掉异常处理中err参数。</li>\n<li>使用浏览器全局变量时加上 window. 前缀。document、console 和 navigator 除外。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">window.alert(\'123\') //ok\nalert(\'123\')//aviod\n</code></pre>\n<ul>\n<li>不允许有连续多行空行。</li>\n<li>每个 var 关键字单独声明一个变量。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">//ok\nvar name = \'curry\'\nvar age = \'18\'\n//aviod\nvar name = \'curry\', age = \'18\'\n</code></pre>\n<ul>\n<li>条件语句中赋值语句使用括号包起来。这样使得代码更加清晰可读，而不会认为是将条件判断语句的全等号（===）错写成了等号（=）。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">// ✓ ok\nwhile ((m = text.match(expr))) {\n  // ...\n}\n\n// ✗ avoid\nwhile (m = text.match(expr)) {\n  // ...\n}\n</code></pre>\n<ul>\n<li>单行代码块两边加空格。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">  function foo () {return true}    // ✗ avoid\n  function foo () { return true }  // ✓ ok\n</code></pre>\n<ul>\n<li>对于变量和函数名统一使用驼峰命名法。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">  function my_function () { }    // ✗ avoid\n  function myFunction () { }     // ✓ ok\n\n  var my_var = \'hello\'           // ✗ avoid\n  var myVar = \'hello\'            // ✓ ok\n</code></pre>\n<ul>\n<li>不允许有多余的行末逗号。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">  var obj = {\n    message: \'hello\',   // ✗ avoid\n  }\n</code></pre>\n<ul>\n<li>始终将逗号置于行末。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">  var obj = {\n    foo: \'foo\'\n    ,bar: \'bar\'   // ✗ avoid\n  }\n\n  var obj = {\n    foo: \'foo\',\n    bar: \'bar\'   // ✓ ok\n  }\n</code></pre>\n<ul>\n<li>键值对当中冒号与值之间要留空白。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">\n</code></pre>\n<ul>\n<li>构造函数要以大写字母开头。</li>\n</ul>\n<pre><code class=\"javascript language-javascript\">function Person () {}\n</code></pre>\n<ul>\n<li>无参的构造函数调用时要带上括号。</li>\n<li>创建数组使用数组字面量而不是构造器。</li>\n<li>同一模块有多个导入时一次性写完。</li>\n<li>switch 一定要使用 break 来将条件分支正常中断。</li>\n<li>不要省去小数点前面的0。</li>\n<li>模板字符串中变量前后不加空格。</li>\n</ul>\n<h2 id=\"vue\">Vue书写规范指南</h2>\n<ul>\n<li>组件名为多个单词，这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。</li>\n<li>组件的 data 必须是一个函数。</li>\n<li>Prop 定义应该尽量详细。至少需要指定其类型。</li>\n<li>在组件上总是必须用 key 配合 v-for，以便维护内部组件及其子树的状态。</li>\n<li>永远不要把 v-if 和 v-for 同时用在同一个元素上。</li>\n<li>为组件样式设置作用域。</li>\n<li>只要有能够拼接文件的构建系统，就把每个组件单独分成文件。</li>\n<li>单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。</li>\n<li>应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V。</li>\n<li>只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性。</li>\n<li>和父组件紧密耦合的子组件应该以父组件名作为前缀命名。</li>\n<li>组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。</li>\n<li>对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。</li>\n<li>在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。</li>\n<li>多个 attribute 的元素应该分多行撰写，每个 attribute 一行。</li>\n<li>组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。</li>\n<li>应该把复杂计算属性分割为尽可能多的更简单的 property。</li>\n<li>指令缩写 (用 : 表示 v-bind:、用 @ 表示 v-on: 和用 # 表示 v-slot:) 应该要么都用要么都不用。</li>\n<li>组件/实例的选项应该有统一的顺序。<ul>\n<li>副作用 (触发组件外的影响)</li>\n<li>全局感知 (要求组件以外的知识)：name、parent</li>\n<li>组件类型 (更改组件的类型)：functional</li>\n<li>模板修改器 (改变模板的编译方式)：delimiters、comments</li>\n<li>模板依赖 (模板内使用的资源)：components、directives、filters</li>\n<li>组合 (向选项里合并 property)：extends、mixins</li>\n<li>接口 (组件的接口)：inheritAttrs、model、props/propsData</li>\n<li>本地状态 (本地的响应式 property)：data、computed</li>\n<li>事件 (通过响应式事件触发的回调)：watch、生命周期钩子 (按照它们被调用的顺序)</li>\n<li>非响应式的 property (不依赖响应系统的实例 property)：methods</li>\n<li>渲染 (组件输出的声明式描述)：template/render、renderError</li></ul></li>\n<li>元素的attribute的顺序<ul>\n<li>定义 (提供组件的选项)：is</li>\n<li>列表渲染 (创建多个变化的相同元素)：v-for</li>\n<li>条件渲染 (元素是否渲染/显示)：v-if、v-else-if、v-else、v-show、v-cloak</li>\n<li>渲染方式 (改变元素的渲染方式)：v-pre、v-once</li>\n<li>全局感知 (需要超越组件的知识)：id</li>\n<li>唯一的 attribute (需要唯一值的 attribute)：ref、key</li>\n<li>双向绑定 (把绑定和事件结合起来)：v-model</li>\n<li>其它 attribute (所有普通的绑定或未绑定的 attribute)</li>\n<li>事件 (组件事件监听器)：v-on（@）</li>\n<li>内容 (覆写元素的内容)：v-html、v-text</li></ul></li>\n<li>单文件组件应该总是让 <code>script</code>、<code>template</code> 和 <code>style</code> 标签的顺序保持一致。且 <code>style</code> 要放在最后，因为另外两个标签至少要有一个。</li>\n<li>应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或变更 prop。</li>\n<li>应该优先通过 Vuex 管理全局状态，而不是通过 this.$root 或一个全局事件总线。</li>\n</ul>', '\n前端代码风格整理\n## HTML\n* 请使用小写元素名 \n```html\n<div></div>\n```\n* 关闭所有 HTML 元素。\n```html\n<section>\n  <p>This is a paragraph.</p>\n  <p>This is a paragraph.</p>\n</section>\n```\n* 关闭空的 HTML 元素。\n```html\n<meta charset=\"utf-8\" />\n```\n* 使用小写属性名。 \n```html\n<div class=\"menu\">\n```\n* 属性值加引号。\n```html\n<table class=\"table striped\">\n```\n* 请始终对图像使用 alt 属性。当图像无法显示时该属性很重要。\n```html\n<img src=\"html5.gif\" alt=\"HTML5\" style=\"width:128px;height:128px\">\n```\n* 等号两边的空格是合法的\n```html\n<link rel = \"stylesheet\" href = \"styles.css\">\n```\n* 尽量避免代码行超过 80 个字符。\n* 短注释应该在单行中书写，并在 <!-- 之后增加一个空格，在 <!-- 之前增加一个空格。长注释，跨越多行，应该通过 <!-- 和 --> 在独立的行中书写。\n* 多个属性应当分行。\n## CSS\n* 为ID和class取通用且有意义的名字。\n* 非必要的情况下，ID和class的名称应尽量简短。\n* 非必要的情况下不要使用元素标签名和ID或class进行组合（div.nav  div#nav）。\n* 写属性值的时候尽量使用缩写。\n* 非必要的情况下 0 后面不用加单位，省略0开头小数点前面的0。。\n* 十六进制尽可能使用3个字符。\n* 缩进所有代码块的内容，它能够提高层次结构的清晰度。\n* 所有声明都要用\";\"结尾。考虑到一致性和拓展性，请在每个声明尾部都加上分号。\n* 在属性名和值之间加一个空格（可不是属性名和冒号之间噢）。\n* 每个选择器和声明都要独立新行。\n* 两个规则之间隔行。\n* CSS书写顺序：\n	* 位置属性(position, top, right, z-index, display, float等)\n	* 大小(width, height, padding, margin)\n	* 文字系列(font, line-height, letter-spacing, color- text-align等)\n	* 背景(background, border等)\n	* 其他(animation, transition等)\n## JAVASCRIPT\n* 使用两个空格进行缩进。\n* 除需要转义的情况外，字符串统一使用单引号。\n```javascript\nlet name = \'curry\' // ok\nlet name = \"curry\" //aviod\n```\n* 不要定义未使用的变量。\n* 关键字后面加空格。\n```javascript\nif (name === \'curry\') {  }  //ok\nif(name===\'curry){ ... } //aviod\n```\n* 函数声明时括号与函数名间加空格。\n```javascript\nfunction name (arg) { ... } //ok\nfunction name(arg){ ... } //aciod\n```\n* 始终使用 === 替代 ==。(例外： obj == null 可以用来检查 null || undefined。)\n```javascript\nif (name === \'curry\') //ok\nif (name == \'curry\') //aviod\n```\n* 字符串拼接操作符 (Infix operators) 之间要留空格。\n```javascript\nlet name = \'stphen\' + name + \'!\' //ok\nlet name = \'stphen\'+name+\'!\' //aviod\n```\n* 逗号后面加空格。\n```javascript\nlet obj = {a: 1, b: 2}//ok\nlet obj = {a: 1,b: 2}//aviod\n```\n* else 关键字要与花括号保持在同一行。\n```javascript\n//ok\nif (...) {\n	...\n} else {\n	...\n}\n\n//aviod\nif (...) {\n	...\n} \nelse\n{\n	...\n}\n```\n* 多行 if 语句的的括号不能省。\n```javascript\n// ✓ ok\nif (options.quiet !== true) console.log(\'done\')\n// ✓ ok\nif (options.quiet !== true) {\n  console.log(\'done\')\n}\n// ✗ avoid\nif (options.quiet !== true)\n  console.log(\'done\')\n```\n* 不要丢掉异常处理中err参数。\n* 使用浏览器全局变量时加上 window. 前缀。document、console 和 navigator 除外。\n```javascript\nwindow.alert(\'123\') //ok\nalert(\'123\')//aviod\n```\n* 不允许有连续多行空行。\n* 每个 var 关键字单独声明一个变量。\n```javascript\n//ok\nvar name = \'curry\'\nvar age = \'18\'\n//aviod\nvar name = \'curry\', age = \'18\'\n```\n* 条件语句中赋值语句使用括号包起来。这样使得代码更加清晰可读，而不会认为是将条件判断语句的全等号（===）错写成了等号（=）。\n```javascript\n// ✓ ok\nwhile ((m = text.match(expr))) {\n  // ...\n}\n\n// ✗ avoid\nwhile (m = text.match(expr)) {\n  // ...\n}\n```\n* 单行代码块两边加空格。\n```javascript\n  function foo () {return true}    // ✗ avoid\n  function foo () { return true }  // ✓ ok\n```\n* 对于变量和函数名统一使用驼峰命名法。\n```javascript\n  function my_function () { }    // ✗ avoid\n  function myFunction () { }     // ✓ ok\n\n  var my_var = \'hello\'           // ✗ avoid\n  var myVar = \'hello\'            // ✓ ok\n```\n* 不允许有多余的行末逗号。\n```javascript\n  var obj = {\n    message: \'hello\',   // ✗ avoid\n  }\n```\n* 始终将逗号置于行末。\n```javascript\n  var obj = {\n    foo: \'foo\'\n    ,bar: \'bar\'   // ✗ avoid\n  }\n\n  var obj = {\n    foo: \'foo\',\n    bar: \'bar\'   // ✓ ok\n  }\n```\n* 键值对当中冒号与值之间要留空白。\n```javascript\n\n```\n* 构造函数要以大写字母开头。\n```javascript\nfunction Person () {}\n```\n* 无参的构造函数调用时要带上括号。\n* 创建数组使用数组字面量而不是构造器。\n* 同一模块有多个导入时一次性写完。\n* switch 一定要使用 break 来将条件分支正常中断。\n* 不要省去小数点前面的0。\n* 模板字符串中变量前后不加空格。\n## Vue书写规范指南\n* 组件名为多个单词，这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。\n* 组件的 data 必须是一个函数。\n* Prop 定义应该尽量详细。至少需要指定其类型。\n* 在组件上总是必须用 key 配合 v-for，以便维护内部组件及其子树的状态。\n* 永远不要把 v-if 和 v-for 同时用在同一个元素上。\n* 为组件样式设置作用域。\n* 只要有能够拼接文件的构建系统，就把每个组件单独分成文件。\n* 单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。\n* 应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V。\n* 只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性。\n* 和父组件紧密耦合的子组件应该以父组件名作为前缀命名。\n* 组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。\n* 对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。\n* 在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。\n* 多个 attribute 的元素应该分多行撰写，每个 attribute 一行。\n* 组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。\n* 应该把复杂计算属性分割为尽可能多的更简单的 property。\n* 指令缩写 (用 : 表示 v-bind:、用 @ 表示 v-on: 和用 # 表示 v-slot:) 应该要么都用要么都不用。\n* 组件/实例的选项应该有统一的顺序。\n	* 副作用 (触发组件外的影响)\n	* 全局感知 (要求组件以外的知识)：name、parent\n	* 组件类型 (更改组件的类型)：functional\n	* 模板修改器 (改变模板的编译方式)：delimiters、comments\n	* 模板依赖 (模板内使用的资源)：components、directives、filters\n	* 组合 (向选项里合并 property)：extends、mixins\n	* 接口 (组件的接口)：inheritAttrs、model、props/propsData\n	* 本地状态 (本地的响应式 property)：data、computed\n	* 事件 (通过响应式事件触发的回调)：watch、生命周期钩子 (按照它们被调用的顺序)\n	* 非响应式的 property (不依赖响应系统的实例 property)：methods\n	* 渲染 (组件输出的声明式描述)：template/render、renderError\n* 元素的attribute的顺序\n	* 定义 (提供组件的选项)：is\n	* 列表渲染 (创建多个变化的相同元素)：v-for\n	* 条件渲染 (元素是否渲染/显示)：v-if、v-else-if、v-else、v-show、v-cloak\n	* 渲染方式 (改变元素的渲染方式)：v-pre、v-once\n	* 全局感知 (需要超越组件的知识)：id\n	* 唯一的 attribute (需要唯一值的 attribute)：ref、key\n	* 双向绑定 (把绑定和事件结合起来)：v-model\n	* 其它 attribute (所有普通的绑定或未绑定的 attribute)\n	* 事件 (组件事件监听器)：v-on（@）\n	* 内容 (覆写元素的内容)：v-html、v-text\n* 单文件组件应该总是让 `script`、`template` 和 `style` 标签的顺序保持一致。且 `style` 要放在最后，因为另外两个标签至少要有一个。\n* 应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或变更 prop。\n* 应该优先通过 Vuex 管理全局状态，而不是通过 this.$root 或一个全局事件总线。\n', '3', '1', '1');
INSERT INTO `artical` VALUES (1000025, '三分钟学会vue中slot插槽的用法', '2021-02-08 08:49:53', '姚文', 366, 3, '插槽，简单理解就是可以即插即用的一段代码。vue中，插槽可以大致分为以下三种：\n\n默认插槽\n具名插槽\n默认插槽\n', 0, 0, '<p><strong>插槽，简单理解就是可以即插即用的一段代码。vue中，插槽可以大致分为以下三种：</strong></p>\n<ul>\n<li>默认插槽</li>\n<li>具名插槽</li>\n<li>默认插槽</li>\n</ul>\n<h2 id=\"1\">1、默认插槽</h2>\n<p>子组件内写法(<code>child.vue</code>)：</p>\n<pre><code class=\"Html language-Html\">&lt;template&gt;\n    &lt;!--组件内其他代码--&gt;\n    &lt;slot&gt;&lt;/slot&gt; \n        &lt;!--组件内其他代码--&gt;\n&lt;/template&gt;\n</code></pre>\n<p>父组件内写法(<code>parent.vue</code>)</p>\n<pre><code class=\"Html language-Html\">&lt;Child&gt;\n  &lt;template&gt;\n      &lt;span&gt;插槽内要显示的内容&lt;/span&gt;\n  &lt;/template&gt;\n&lt;/Child&gt;\n</code></pre>\n<p>最后渲染出来的结果:</p>\n<pre><code class=\"Html language-Html\">&lt;!--组件内其他代码--&gt;\n&lt;span&gt;插槽内要显示的内容&lt;/span&gt;\n&lt;!--组件内其他代码--&gt;\n</code></pre>\n<p><strong>所以，简单来说，默认插槽就是子组件内占了一个位置，在父组件内调用子组件的时候，写入什么内容，就会在这个位置显示出什么内容来。</strong></p>\n<h2 id=\"2\">2、具名插槽</h2>\n<p>子组件内写法(<code>child.vue</code>)：</p>\n<pre><code class=\"Html language-Html\">&lt;template&gt; \n    &lt;!--组件内其他代码--&gt;\n    &lt;slot name=\"slot1\"&gt;&lt;/slot&gt;\n    &lt;slot&gt;&lt;/slot&gt; \n    &lt;slot name=\"slot2\"&gt;&lt;/slot&gt;\n    &lt;!--组件内其他代码--&gt;\n&lt;/template&gt;\n</code></pre>\n<p>父组件内写法(<code>parent.vue</code>):</p>\n<pre><code class=\"Html language-Html\">&lt;Child&gt;\n  &lt;template v-slot=\"slot1\"&gt;\n      &lt;span&gt;插槽slot1内显示的内容&lt;/span&gt;\n  &lt;/template&gt;\n  &lt;!--也可以使用 #插槽名 的形式--&gt;\n  &lt;template #slot2&gt;\n      &lt;span&gt;插槽slot2内显示的内容&lt;/span&gt;\n  &lt;/template&gt;\n  &lt;template&gt;\n      &lt;span&gt;默认插槽内要显示的内容&lt;/span&gt;\n  &lt;/template&gt;\n&lt;/Child&gt;\n</code></pre>\n<p>最后渲染出来的结果:</p>\n<pre><code class=\"Html language-Html\">&lt;!--组件内其他代码--&gt;\n&lt;span&gt;插槽slot1内显示的内容&lt;/span&gt;\n&lt;span&gt;插槽内要显示的内容&lt;/span&gt;\n&lt;span&gt;默认插槽内要显示的内容&lt;/span&gt;\n&lt;!--组件内其他代码--&gt;\n</code></pre>\n<p>由此可见，具名插槽就是，子组件内定义插槽的时候，取了一个名字，父组件调用的时候，通过<code>v-slot=\"插槽name\"</code>指令将内容分发至指定位置，从而在页面渲染出来。需要注意的是：最后渲染出来的内容，是由子组件内定义的插槽的内容位置，与父组件内调用时传入的slot顺序没有关系。</p>\n<h2 id=\"3\">3、作用域插槽</h2>\n<p>有时候，我们在插槽内想访问子组件内的数据时，就需要用到作用域插槽。</p>\n<p>子组件内写法(<code>child.vue</code>)：</p>\n<pre><code class=\"Html language-Html\">&lt;template&gt; \n    &lt;!--组件内其他代码--&gt;\n    &lt;slot name=\"slot1\" propsName=\"我是子组件内slot1的数据\"&gt;&lt;/slot&gt;\n    &lt;slot name=\"slot2\" :propsName=\"{a:1,b:2}\"&gt;&lt;/slot&gt;\n    &lt;!--组件内其他代码--&gt;\n&lt;/template&gt;\n</code></pre>\n<p>父组件内写法(<code>parent.vue</code>):</p>\n<pre><code class=\"Html language-Html\">&lt;Child&gt;\n  &lt;template #slot1=\"data\"&gt;\n      &lt;span&gt;{{data.propsName}}&lt;/span&gt;\n  &lt;/template&gt;\n  &lt;template #slot2=\"data\"&gt;\n      &lt;span&gt;{{data.propsName.a}} ---- {{data.propsName.b}}&lt;/span&gt;\n  &lt;/template&gt;\n&lt;/Child&gt;\n</code></pre>\n<p>最后渲染出来的结果:</p>\n<pre><code class=\"Html language-Html\">&lt;!--组件内其他代码--&gt;\n&lt;span&gt;我是子组件内slot1的数据&lt;/span&gt;\n&lt;span&gt;1---2&lt;/span&gt;\n&lt;!--组件内其他代码--&gt;\n</code></pre>\n<p>作用域插槽，就是在子组件内以<code>propName=\"data\"</code>的形式传数据，在父组件写插槽的时候用<code>#插槽名=\"定义的对象名\"</code>的形式接受，插槽内用<code>{{定义的对象名.propName}}</code>的形式使用数据。也可以用过解构的写法：</p>\n<p>子组件内写法(<code>child.vue</code>)：</p>\n<pre><code class=\"Html language-Html\">&lt;template&gt; \n    &lt;!--组件内其他代码--&gt;\n    &lt;slot name=\"slot1\" prop1=\"我是prop1的内容\" prop2=\"我是prop2的内容\"&gt;&lt;/slot&gt;\n    &lt;!--组件内其他代码--&gt;\n&lt;/template&gt;\n</code></pre>\n<p>父组件内写法(<code>parent.vue</code>):</p>\n<pre><code class=\"Html language-Html\">&lt;Child&gt;\n  &lt;template #slot1=\"{prop1, prop2}\"&gt;\n      &lt;span&gt;{{prop1}}-----{{prop2}}&lt;/span&gt;\n  &lt;/template&gt;\n&lt;/Child&gt;\n</code></pre>\n<p>最后渲染出来的结果:</p>\n<pre><code class=\"Html language-Html\">&lt;span&gt;我是prop1的内容-----我是prop2的内容&lt;/span&gt;\n</code></pre>\n<h2 id=\"\">总结</h2>\n<p>插槽虽然在日常封装的简单组件中比较少用到，但却是封装高级组件中必不可少的功能，插槽可以大大提高组件的可复用性。例如：一个组件，在A页面与B页面调用时，只有组局部稍有差异，或者这部分内容在每个页面显示的形态都不一样，就可采用插槽的形式封装这部分。 </p>\n<p>当然，此次分享作者也只是抛砖引玉，欢迎各位大佬分享指正。</p>', '**插槽，简单理解就是可以即插即用的一段代码。vue中，插槽可以大致分为以下三种：**\n* 默认插槽\n* 具名插槽\n* 默认插槽\n\n## 1、默认插槽\n\n子组件内写法(`child.vue`)：\n```Html\n<template>\n	<!--组件内其他代码-->\n	<slot></slot> \n    	<!--组件内其他代码-->\n</template>\n```\n父组件内写法(`parent.vue`)\n```Html\n<Child>\n  <template>\n  	<span>插槽内要显示的内容</span>\n  </template>\n</Child>\n```\n最后渲染出来的结果:\n```Html\n<!--组件内其他代码-->\n<span>插槽内要显示的内容</span>\n<!--组件内其他代码-->\n```\n**所以，简单来说，默认插槽就是子组件内占了一个位置，在父组件内调用子组件的时候，写入什么内容，就会在这个位置显示出什么内容来。**\n\n## 2、具名插槽\n\n子组件内写法(`child.vue`)：\n```Html\n<template> \n    <!--组件内其他代码-->\n    <slot name=\"slot1\"></slot>\n    <slot></slot> \n    <slot name=\"slot2\"></slot>\n    <!--组件内其他代码-->\n</template>\n```\n父组件内写法(`parent.vue`):\n```Html\n<Child>\n  <template v-slot=\"slot1\">\n  	<span>插槽slot1内显示的内容</span>\n  </template>\n  <!--也可以使用 #插槽名 的形式-->\n  <template #slot2>\n  	<span>插槽slot2内显示的内容</span>\n  </template>\n  <template>\n  	<span>默认插槽内要显示的内容</span>\n  </template>\n</Child>\n```\n最后渲染出来的结果:\n```Html\n<!--组件内其他代码-->\n<span>插槽slot1内显示的内容</span>\n<span>插槽内要显示的内容</span>\n<span>默认插槽内要显示的内容</span>\n<!--组件内其他代码-->\n```\n由此可见，具名插槽就是，子组件内定义插槽的时候，取了一个名字，父组件调用的时候，通过`v-slot=\"插槽name\"`指令将内容分发至指定位置，从而在页面渲染出来。需要注意的是：最后渲染出来的内容，是由子组件内定义的插槽的内容位置，与父组件内调用时传入的slot顺序没有关系。\n\n## 3、作用域插槽\n\n有时候，我们在插槽内想访问子组件内的数据时，就需要用到作用域插槽。\n\n子组件内写法(`child.vue`)：\n```Html\n<template> \n    <!--组件内其他代码-->\n    <slot name=\"slot1\" propsName=\"我是子组件内slot1的数据\"></slot>\n    <slot name=\"slot2\" :propsName=\"{a:1,b:2}\"></slot>\n    <!--组件内其他代码-->\n</template>\n```\n父组件内写法(`parent.vue`):\n```Html\n<Child>\n  <template #slot1=\"data\">\n  	<span>{{data.propsName}}</span>\n  </template>\n  <template #slot2=\"data\">\n  	<span>{{data.propsName.a}} ---- {{data.propsName.b}}</span>\n  </template>\n</Child>\n```\n最后渲染出来的结果:\n```Html\n<!--组件内其他代码-->\n<span>我是子组件内slot1的数据</span>\n<span>1---2</span>\n<!--组件内其他代码-->\n```\n作用域插槽，就是在子组件内以`propName=\"data\"`的形式传数据，在父组件写插槽的时候用`#插槽名=\"定义的对象名\"`的形式接受，插槽内用`{{定义的对象名.propName}}`的形式使用数据。也可以用过解构的写法：\n\n子组件内写法(`child.vue`)：\n```Html\n<template> \n    <!--组件内其他代码-->\n    <slot name=\"slot1\" prop1=\"我是prop1的内容\" prop2=\"我是prop2的内容\"></slot>\n    <!--组件内其他代码-->\n</template>\n```\n父组件内写法(`parent.vue`):\n```Html\n<Child>\n  <template #slot1=\"{prop1, prop2}\">\n  	<span>{{prop1}}-----{{prop2}}</span>\n  </template>\n</Child>\n```\n最后渲染出来的结果:\n```Html\n<span>我是prop1的内容-----我是prop2的内容</span>\n```\n\n## 总结\n插槽虽然在日常封装的简单组件中比较少用到，但却是封装高级组件中必不可少的功能，插槽可以大大提高组件的可复用性。例如：一个组件，在A页面与B页面调用时，只有组局部稍有差异，或者这部分内容在每个页面显示的形态都不一样，就可采用插槽的形式封装这部分。 \n\n当然，此次分享作者也只是抛砖引玉，欢迎各位大佬分享指正。', '5', '1', '1');
INSERT INTO `artical` VALUES (1000026, '操作DOM节点常用的4种方法及克隆DOM节点的方法', '2021-02-01 14:20:59', '姚文', 222, 7, '操作DOM节点的方法总结', 0, 0, '<h1 id=\"1dom\">1、常用的操作DOM节点方法：</h1>\n<h2 id=\"appendchild\">appendChild()</h2>\n<p>父节点调用此方法，传入的新节点，将插入到最后一个节点的后面。</p>\n<pre><code>var returnedNode = someNode.appendChild(newNode); \nalert(returnedNode == newNode); //true \nalert(someNode.lastChild == newNode); //true\n</code></pre>\n<h2 id=\"insertbefore\">insertBefore()</h2>\n<p>父节点调用此方法，接受两个参数：要插入的节点和参照的节点，插入节点后，插入的新节点会作为参照节点的兄弟节点，在参照节点的前一个展示。如果参照节点是null，则和appendChild()方法一样，插入到最后一个。</p>\n<pre><code>returnedNode = someNode.insertBefore(newNode, null); \nalert(newNode == someNode.lastChild); //true\n\nvar returnedNode = someNode.insertBefore(newNode, someNode.firstChild); \nalert(returnedNode == newNode); //true\nalert(newNode == someNode.firstChild); //true\n\nreturnedNode = someNode.insertBefore(newNode, someNode.lastChild); \nalert(newNode == someNode.childNodes[someNode.childNodes.length-2]); //true\n</code></pre>\n<h2 id=\"replacechild\">replaceChild()</h2>\n<p>替换节点，此方法接收两个参数：新节点和要替换的节点，返回要替换的节点。</p>\n<pre><code>var returnedNode = someNode.replaceChild(newNode, someNode.firstChild);\n\nreturnedNode = someNode.replaceChild(newNode, someNode.lastChild);\n</code></pre>\n<h2 id=\"removechild\">removeChild()</h2>\n<p>移除某一个节点，传入要移除的节点。</p>\n<pre><code>var formerFirstChild = someNode.removeChild(someNode.firstChild);\n\nvar formerLastChild = someNode.removeChild(someNode.lastChild);\n</code></pre>\n<p><strong>以上四个方法，都是操作的某个节点的字节点，所以要先获取到父节点，然后父节点调用方法，操作其子节点。</strong></p>\n<h1 id=\"\">克隆节点的方法</h1>\n<h2 id=\"clonenode\">cloneNode()</h2>\n<p>此方法接受一个布尔值的参数，true表示深复制，复制整个节点树及其子节点，false表示浅复制，仅复制当前节点本身。</p>\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;item 1&lt;/li&gt;\n    &lt;li&gt;item 2&lt;/li&gt;\n    &lt;li&gt;item 3&lt;/li&gt;\n &lt;/ul&gt;\n //假设以上节点保存在变量myList中\n var deepList = myList.cloneNode(true);\n alert(deepList.childNodes.length); //3（IE&lt;9）或7（其他浏览器）\n\n var shallowList = myList.cloneNode(false);\n alert(shallowList.childNodes.length);\n</code></pre>\n<p>上面的例子中，deepList中保存了mList执行深复制拷贝的节点，所有将其子节点一并全部复制；而shallowList是执行浅复制拷贝的节点，只复制了ul本身，所以其childNodes长度为0。</p>', '\n# 1、常用的操作DOM节点方法：\n## appendChild()\n父节点调用此方法，传入的新节点，将插入到最后一个节点的后面。\n```\nvar returnedNode = someNode.appendChild(newNode); \nalert(returnedNode == newNode); //true \nalert(someNode.lastChild == newNode); //true\n```\n## insertBefore()\n父节点调用此方法，接受两个参数：要插入的节点和参照的节点，插入节点后，插入的新节点会作为参照节点的兄弟节点，在参照节点的前一个展示。如果参照节点是null，则和appendChild()方法一样，插入到最后一个。\n```\nreturnedNode = someNode.insertBefore(newNode, null); \nalert(newNode == someNode.lastChild); //true\n\nvar returnedNode = someNode.insertBefore(newNode, someNode.firstChild); \nalert(returnedNode == newNode); //true\nalert(newNode == someNode.firstChild); //true\n\nreturnedNode = someNode.insertBefore(newNode, someNode.lastChild); \nalert(newNode == someNode.childNodes[someNode.childNodes.length-2]); //true\n```\n## replaceChild()\n替换节点，此方法接收两个参数：新节点和要替换的节点，返回要替换的节点。\n```\nvar returnedNode = someNode.replaceChild(newNode, someNode.firstChild);\n\nreturnedNode = someNode.replaceChild(newNode, someNode.lastChild);\n```\n## removeChild()\n移除某一个节点，传入要移除的节点。\n```\nvar formerFirstChild = someNode.removeChild(someNode.firstChild);\n\nvar formerLastChild = someNode.removeChild(someNode.lastChild);\n```\n**以上四个方法，都是操作的某个节点的字节点，所以要先获取到父节点，然后父节点调用方法，操作其子节点。**\n\n# 克隆节点的方法\n## cloneNode()\n此方法接受一个布尔值的参数，true表示深复制，复制整个节点树及其子节点，false表示浅复制，仅复制当前节点本身。\n```\n<ul>\n    <li>item 1</li>\n    <li>item 2</li>\n    <li>item 3</li>\n </ul>\n //假设以上节点保存在变量myList中\n var deepList = myList.cloneNode(true);\n alert(deepList.childNodes.length); //3（IE<9）或7（其他浏览器）\n \n var shallowList = myList.cloneNode(false);\n alert(shallowList.childNodes.length);\n```\n上面的例子中，deepList中保存了mList执行深复制拷贝的节点，所有将其子节点一并全部复制；而shallowList是执行浅复制拷贝的节点，只复制了ul本身，所以其childNodes长度为0。', '1', '1', '1');
INSERT INTO `artical` VALUES (1000027, 'UNI-APP Android端本地打包全流程', '2021-02-01 14:28:20', '姚文', 132, 9, 'UNI-app 本地打包全流程', 0, 0, '<p><strong>UNIAPP本地打包官网：<a href=\"https://nativesupport.dcloud.net.cn/AppDocs/usesdk/android\">Android原生工程配置</a></strong></p>\n<h3 id=\"\">一、配置本地开发环境</h3>\n<p>1、Android Studio：下载地址：<a href=\"https://developer.android.google.cn/studio/index.html\">Android Studio官网</a><br />\n2、<a href=\"https://www.dcloud.io/hbuilderx.html\">HBuilderX </a><br />\n3、App离线SDK下载：<a href=\"https://nativesupport.dcloud.net.cn/AppDocs/download/android\">最新android平台SDK下载</a></p>\n<h3 id=\"-1\">二、新建工程</h3>\n<h4 id=\"1androidstudio\">1、打开Android studio新建一个空白项目</h4>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ca12878b1e948e28c9df7da8c589a4b~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/602e139a24704e358e5ae570fbc7c7d0~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<h3 id=\"-2\">三、配置工程</h3>\n<h4 id=\"1project\">1、首先切换到<code>project</code>目录下</h4>\n<p><img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c69081a9ed7460d91e7762722e42a0f~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<h4 id=\"2appbuildgradle\">2、配置打包信息（app/build.gradle）</h4>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20919502d2af4e9495fa6ad617117bfe~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<p>作者配置的基础的<code>build.gradle</code>，仅供参考</p>\n<pre><code>plugins {\n    id \'com.android.application\'\n}\n\nandroid {\n    compileSdkVersion 30\n    buildToolsVersion \"30.0.3\"\n\n    defaultConfig {\n        applicationId \"xxxxx\"   //包名\n        minSdkVersion 21\n        targetSdkVersion 30\n        versionCode 29\n        versionName \"2.0.29\"\n        multiDexEnabled true\n//        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile(\'proguard-android-optimize.txt\'), \'proguard-rules.pro\'\n        }\n    }\n//    compileOptions {\n//        sourceCompatibility JavaVersion.VERSION_1_8\n//        targetCompatibility JavaVersion.VERSION_1_8\n//    }\n    aaptOptions {\n        additionalParameters \'--auto-add-overlay\'\n        ignoreAssetsPattern \"!.svn:!.git:.*:!CVS:!thumbs.db:!picasa.ini:!*.scc:*~\"\n    }\n}\n\ndependencies {\n\n    implementation \'androidx.appcompat:appcompat:1.1.0\'\n    implementation \'com.google.android.material:material:1.1.0\'\n    implementation \'androidx.constraintlayout:constraintlayout:1.1.3\'\n    testImplementation \'junit:junit:4.+\'\n    androidTestImplementation \'androidx.test.ext:junit:1.1.1\'\n    androidTestImplementation \'androidx.test.espresso:espresso-core:3.2.0\'\n    implementation fileTree(dir: \'libs\', include: [\'*.aar\', \'*.jar\'], exclude: [])\n    //noinspection GradleCompatible\n    implementation \"com.android.support:support-v4:28.0.0\"\n    //noinspection GradleCompatible\n    implementation \"com.android.support:appcompat-v7:28.0.0\"\n    //noinspection GradleCompatible\n    implementation \'com.android.support:recyclerview-v7:28.0.0\'\n    implementation \'com.facebook.fresco:fresco:1.13.0\'\n    implementation \"com.facebook.fresco:animated-gif:1.13.0\"\n    implementation \'com.github.bumptech.glide:glide:4.9.0\'\n    implementation \'com.alibaba:fastjson:1.1.46.android\'\n}\n</code></pre>\n<h4 id=\"3\">3、配置应用名称</h4>\n<p>打开app-&gt; src -&gt; main -&gt; res -&gt; values -&gt; strings.xml文件，修改“app_name”字段值，该值为安装到手机上桌面显示的应用名称，建议与manifest.json中name（基础配置中的应用名称）对应。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80fbef64ff0f43f28c207533871fbdc5~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<h4 id=\"4provider\">4、配置应用启动页及provider节点</h4>\n<p><strong>注意：新建的项目默认会有一个MainActivity的节点，必须删掉！</strong></p>\n<p>基础启动页配置代码，仅供参考：</p>\n<pre><code>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"${xxx}\"&gt;\n    &lt;uses-permission android:name=\"android.permission.USE_FINGERPRINT\"/&gt;\n    &lt;uses-permission android:name=\"android.permission.GET_ACCOUNTS\"/&gt;\n    &lt;uses-permission android:name=\"android.permission.WRITE_CONTACTS\"/&gt;\n    &lt;uses-permission android:name=\"android.permission.READ_CONTACTS\"/&gt;\n    &lt;application\n        android:allowBackup=\"true\"\n        android:icon=\"@drawable/icon\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.MyApplication\"&gt;\n        &lt;activity\n            android:name=\"io.dcloud.PandoraEntry\"\n            android:configChanges=\"orientation|keyboardHidden|keyboard|navigation\"\n            android:label=\"@string/app_name\"\n            android:launchMode=\"singleTask\"\n            android:hardwareAccelerated=\"true\"\n            android:theme=\"@style/TranslucentTheme\"\n            android:screenOrientation=\"user\"\n            android:windowSoftInputMode=\"adjustResize\" &gt;\n            &lt;intent-filter&gt;\n                &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n                &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n        &lt;activity\n            android:name=\"io.dcloud.PandoraEntryActivity\"\n            android:launchMode=\"singleTask\"\n            android:configChanges=\"orientation|keyboardHidden|screenSize|mcc|mnc|fontScale|keyboard\"\n            android:hardwareAccelerated=\"true\"\n            android:permission=\"com.miui.securitycenter.permission.AppPermissionsEditor\"\n            android:screenOrientation=\"user\"\n            android:theme=\"@style/DCloudTheme\"\n            android:windowSoftInputMode=\"adjustResize\"&gt;\n            &lt;intent-filter&gt;\n                &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n                &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt;\n                &lt;action android:name=\"android.intent.action.VIEW\" /&gt;\n                &lt;data android:scheme=\"h56131bcf\" /&gt;\n            &lt;/intent-filter&gt;\n        &lt;/activity&gt;\n        &lt;!--provider节点必须添加--&gt;\n        &lt;provider\n            android:name=\"io.dcloud.common.util.DCloud_FileProvider\"\n            android:authorities=\"${xxx}.dc.fileprovider\"\n            android:exported=\"false\"\n            android:grantUriPermissions=\"true\"&gt;\n            &lt;meta-data\n                android:name=\"android.support.FILE_PROVIDER_PATHS\"\n                android:resource=\"@xml/dcloud_file_provider\" /&gt;\n        &lt;/provider&gt;\n    &lt;/application&gt;\n\n&lt;/manifest&gt;\n</code></pre>\n<p>注意：${xxx}为包名</p>\n<h4 id=\"5\">5、配置应用图标和启动界面</h4>\n<blockquote>\n  <p>icon.png为应用的图标。push.png为推送消息的图标。  splash.png为应用启动页的图标。</p>\n</blockquote>\n<p>注意：图表相关尺寸，请自行百度。</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d14bb0fec5e542bda5eec344d546b917~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<p>修改Androidmanifest.xml中application节点的icon属性为@drawable/icon</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7cf101475d24845ba0832f90cbb4962~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<h4 id=\"6\">6、资源配置</h4>\n<p>Android studio默认项目没有assets文件夹，需手动创建，创建位置与java目录同级。</p>\n<ul>\n<li><p>创建data文件夹并拷贝资源：将SDK-&gt;assets-&gt;data文件夹拷贝到刚刚创建的assets文件夹下，如下图：\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0792780a86084c3a9a11f942cb05a71b~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p></li>\n<li><p>创建apps文件夹并拷贝资源：将HBuilderX中的项目导出，将导出的资源复制到assets-&gt;apps下，如下图所示：</p></li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dbaa9e727bb4a7a90f8180cb45074dd~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7411de54d924cf0839dec101d59ce67~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<ul>\n<li>修改dcloud<em>control.xml文件：修改dcloud</em>control.xml中的appid为拷贝过来的5+APP的id，确保dcloud_control.xml中的appid与manifest.json中的id与文件夹名一致，如下图所示：</li>\n</ul>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9bcb32d7eed40238f2980378da64064~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<p>至此，所有的工程配置已完成，可以连上手机USB调试，运行项目，如果可以成功在手机上打开app，则证明配置成功，运行项目如下：\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cc8c9fa533f4127b292b2c8b2eb84dd~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<h3 id=\"-3\">三、应用打包</h3>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8b4642e9b9c4560a9739923878803d2~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" />\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d8e4802ecf148219f5114d8bbdfe2a5~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" />\n<img src=\"https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cba51946a43b4bfd816d6e8538a8be32~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" />\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f3ccfd8f2ac47bca185b772ce395514~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" />\n<img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e4711be3cba4cc1b33744be5331d69b~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>', '\n**UNIAPP本地打包官网：[Android原生工程配置](https://nativesupport.dcloud.net.cn/AppDocs/usesdk/android)**\n\n### 一、配置本地开发环境\n\n1、Android Studio：下载地址：[Android Studio官网](https://developer.android.google.cn/studio/index.html)  \n2、[HBuilderX ](https://www.dcloud.io/hbuilderx.html)  \n3、App离线SDK下载：[最新android平台SDK下载](https://nativesupport.dcloud.net.cn/AppDocs/download/android)\n\n### 二、新建工程  \n#### 1、打开Android studio新建一个空白项目\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5ca12878b1e948e28c9df7da8c589a4b~tplv-k3u1fbpfcp-watermark.image)\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/602e139a24704e358e5ae570fbc7c7d0~tplv-k3u1fbpfcp-watermark.image)\n\n### 三、配置工程\n#### 1、首先切换到`project`目录下\n\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6c69081a9ed7460d91e7762722e42a0f~tplv-k3u1fbpfcp-watermark.image)\n\n#### 2、配置打包信息（app/build.gradle）\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20919502d2af4e9495fa6ad617117bfe~tplv-k3u1fbpfcp-watermark.image)\n\n作者配置的基础的`build.gradle`，仅供参考\n```\nplugins {\n    id \'com.android.application\'\n}\n\nandroid {\n    compileSdkVersion 30\n    buildToolsVersion \"30.0.3\"\n\n    defaultConfig {\n        applicationId \"xxxxx\"   //包名\n        minSdkVersion 21\n        targetSdkVersion 30\n        versionCode 29\n        versionName \"2.0.29\"\n        multiDexEnabled true\n//        testInstrumentationRunner \"androidx.test.runner.AndroidJUnitRunner\"\n    }\n\n    buildTypes {\n        release {\n            minifyEnabled false\n            proguardFiles getDefaultProguardFile(\'proguard-android-optimize.txt\'), \'proguard-rules.pro\'\n        }\n    }\n//    compileOptions {\n//        sourceCompatibility JavaVersion.VERSION_1_8\n//        targetCompatibility JavaVersion.VERSION_1_8\n//    }\n    aaptOptions {\n        additionalParameters \'--auto-add-overlay\'\n        ignoreAssetsPattern \"!.svn:!.git:.*:!CVS:!thumbs.db:!picasa.ini:!*.scc:*~\"\n    }\n}\n\ndependencies {\n\n    implementation \'androidx.appcompat:appcompat:1.1.0\'\n    implementation \'com.google.android.material:material:1.1.0\'\n    implementation \'androidx.constraintlayout:constraintlayout:1.1.3\'\n    testImplementation \'junit:junit:4.+\'\n    androidTestImplementation \'androidx.test.ext:junit:1.1.1\'\n    androidTestImplementation \'androidx.test.espresso:espresso-core:3.2.0\'\n    implementation fileTree(dir: \'libs\', include: [\'*.aar\', \'*.jar\'], exclude: [])\n    //noinspection GradleCompatible\n    implementation \"com.android.support:support-v4:28.0.0\"\n    //noinspection GradleCompatible\n    implementation \"com.android.support:appcompat-v7:28.0.0\"\n    //noinspection GradleCompatible\n    implementation \'com.android.support:recyclerview-v7:28.0.0\'\n    implementation \'com.facebook.fresco:fresco:1.13.0\'\n    implementation \"com.facebook.fresco:animated-gif:1.13.0\"\n    implementation \'com.github.bumptech.glide:glide:4.9.0\'\n    implementation \'com.alibaba:fastjson:1.1.46.android\'\n}\n```\n\n#### 3、配置应用名称\n\n打开app-> src -> main -> res -> values -> strings.xml文件，修改“app_name”字段值，该值为安装到手机上桌面显示的应用名称，建议与manifest.json中name（基础配置中的应用名称）对应。\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/80fbef64ff0f43f28c207533871fbdc5~tplv-k3u1fbpfcp-watermark.image)\n\n#### 4、配置应用启动页及provider节点\n\n**注意：新建的项目默认会有一个MainActivity的节点，必须删掉！**\n\n基础启动页配置代码，仅供参考：\n```\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n    package=\"${xxx}\">\n    <uses-permission android:name=\"android.permission.USE_FINGERPRINT\"/>\n    <uses-permission android:name=\"android.permission.GET_ACCOUNTS\"/>\n    <uses-permission android:name=\"android.permission.WRITE_CONTACTS\"/>\n    <uses-permission android:name=\"android.permission.READ_CONTACTS\"/>\n    <application\n        android:allowBackup=\"true\"\n        android:icon=\"@drawable/icon\"\n        android:label=\"@string/app_name\"\n        android:roundIcon=\"@mipmap/ic_launcher_round\"\n        android:supportsRtl=\"true\"\n        android:theme=\"@style/Theme.MyApplication\">\n        <activity\n            android:name=\"io.dcloud.PandoraEntry\"\n            android:configChanges=\"orientation|keyboardHidden|keyboard|navigation\"\n            android:label=\"@string/app_name\"\n            android:launchMode=\"singleTask\"\n            android:hardwareAccelerated=\"true\"\n            android:theme=\"@style/TranslucentTheme\"\n            android:screenOrientation=\"user\"\n            android:windowSoftInputMode=\"adjustResize\" >\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n        <activity\n            android:name=\"io.dcloud.PandoraEntryActivity\"\n            android:launchMode=\"singleTask\"\n            android:configChanges=\"orientation|keyboardHidden|screenSize|mcc|mnc|fontScale|keyboard\"\n            android:hardwareAccelerated=\"true\"\n            android:permission=\"com.miui.securitycenter.permission.AppPermissionsEditor\"\n            android:screenOrientation=\"user\"\n            android:theme=\"@style/DCloudTheme\"\n            android:windowSoftInputMode=\"adjustResize\">\n            <intent-filter>\n                <category android:name=\"android.intent.category.DEFAULT\" />\n                <category android:name=\"android.intent.category.BROWSABLE\" />\n                <action android:name=\"android.intent.action.VIEW\" />\n                <data android:scheme=\"h56131bcf\" />\n            </intent-filter>\n        </activity>\n        <!--provider节点必须添加-->\n        <provider\n            android:name=\"io.dcloud.common.util.DCloud_FileProvider\"\n            android:authorities=\"${xxx}.dc.fileprovider\"\n            android:exported=\"false\"\n            android:grantUriPermissions=\"true\">\n            <meta-data\n                android:name=\"android.support.FILE_PROVIDER_PATHS\"\n                android:resource=\"@xml/dcloud_file_provider\" />\n        </provider>\n    </application>\n\n</manifest>\n```\n注意：${xxx}为包名\n\n\n#### 5、配置应用图标和启动界面\n\n> icon.png为应用的图标。push.png为推送消息的图标。  splash.png为应用启动页的图标。\n\n注意：图表相关尺寸，请自行百度。\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d14bb0fec5e542bda5eec344d546b917~tplv-k3u1fbpfcp-watermark.image)\n\n修改Androidmanifest.xml中application节点的icon属性为@drawable/icon\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e7cf101475d24845ba0832f90cbb4962~tplv-k3u1fbpfcp-watermark.image)\n\n\n#### 6、资源配置\nAndroid studio默认项目没有assets文件夹，需手动创建，创建位置与java目录同级。\n\n* 创建data文件夹并拷贝资源：将SDK->assets->data文件夹拷贝到刚刚创建的assets文件夹下，如下图：\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0792780a86084c3a9a11f942cb05a71b~tplv-k3u1fbpfcp-watermark.image)\n\n* 创建apps文件夹并拷贝资源：将HBuilderX中的项目导出，将导出的资源复制到assets->apps下，如下图所示：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4dbaa9e727bb4a7a90f8180cb45074dd~tplv-k3u1fbpfcp-watermark.image)\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c7411de54d924cf0839dec101d59ce67~tplv-k3u1fbpfcp-watermark.image)\n\n* 修改dcloud_control.xml文件：修改dcloud_control.xml中的appid为拷贝过来的5+APP的id，确保dcloud_control.xml中的appid与manifest.json中的id与文件夹名一致，如下图所示：\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b9bcb32d7eed40238f2980378da64064~tplv-k3u1fbpfcp-watermark.image)\n\n\n至此，所有的工程配置已完成，可以连上手机USB调试，运行项目，如果可以成功在手机上打开app，则证明配置成功，运行项目如下：\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2cc8c9fa533f4127b292b2c8b2eb84dd~tplv-k3u1fbpfcp-watermark.image)\n\n### 三、应用打包\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e8b4642e9b9c4560a9739923878803d2~tplv-k3u1fbpfcp-watermark.image)\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d8e4802ecf148219f5114d8bbdfe2a5~tplv-k3u1fbpfcp-watermark.image)\n![](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cba51946a43b4bfd816d6e8538a8be32~tplv-k3u1fbpfcp-watermark.image)\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/1f3ccfd8f2ac47bca185b772ce395514~tplv-k3u1fbpfcp-watermark.image)\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8e4711be3cba4cc1b33744be5331d69b~tplv-k3u1fbpfcp-watermark.image)', '3', '1', '1');
INSERT INTO `artical` VALUES (1000033, 'Vue中几个常用的方法：$attrs、$listeners、$nextTick...', '2021-02-03 16:52:50', '姚文', 99, 3, 'vue中$set、$attrs、$listeners、$nextTick的使用方法', 0, 0, '<h2 id=\"dset\">$set</h2>\n<p>参数说明</p>\n<pre><code class=\"JavaScript language-JavaScript\">{Object | Array} target\n{string | number} propertyName/index\n{any} value\n</code></pre>\n<p>众所周知，vue2的数据响应式系统主要基于<code>Object.defineProperty</code>方法来实现，基于数据生成虚拟DOM，当Watcher监测到数据变化时，比较更新虚拟DOM，从而实现页面的变化。但是，对于Watcher监测不到的更新，就无法触发虚拟DOM的比较，因此会出现数据更新，页面没有刷新的现象。例如：给对象中增加属性、通过下标的方式改变数组等，就会出现此问题。</p>\n<p>而$set方法就是用来解决上述问题，它会向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。</p>\n<pre><code class=\"JavaScript language-JavaScript\">//操作数组 arr\nthis.$set(this.arr, index, newVal)\n//操作对象obj\nthis.$set(this.obj, newProperty, newVal)\n</code></pre>\n<h2 id=\"dattrs\">$attrs</h2>\n<p>$attrs中包含了父级组件中所传递的没有没prop识别的attribute绑定值（除了style和class之外），例如：</p>\n<pre><code class=\"JavaScript language-JavaScript\">//父组件中\n&lt;child title=\"title\" id=\"id\" info=\"info\"&gt;&lt;/child&gt;\n\n//子组件中的props中只识别了title，因此剩余的id、info绑定值就可以从$attrs中获取\nprops: {\n   title: String\n}\nmounted() {\n   console.log(this.$attrs.id, this.$attrs.info)   //id  info\n}\n</code></pre>\n<p>$attrs在封装高级组件时是特别好用，例如涉及到多级组件传参在中间组件中用<code>v-bind=\"$attrs\"</code>即可把没有被当前prop识别的attribute传递到子级组件中。</p>\n<pre><code class=\"JavaScript language-JavaScript\">//父组件中\n&lt;child title=\"title\" id=\"id\" info=\"info\"&gt;&lt;/child&gt;\n\n//子级组件\n&lt;other v-bind=\"$attrs\"&gt;&lt;/other&gt;\nprops: {\n   title: String\n}\n//other组件中\nprops: {\n   id: String, //id\n   info: String //info\n}\n</code></pre>\n<h2 id=\"dlisteners\">$listeners</h2>\n<p>$listeners与$attrs对应，$listeners包含了父级组件中（不含 .native 修饰器的）v-on监听的事件，同样在封装高级组件中特别好用。</p>\n<pre><code class=\"JavaScript language-JavaScript\">//父组件中\n&lt;child @change=\"handleChange\" @select=\"handleSelect\"&gt;&lt;/child&gt;\n\nmethods: {\n    handleChange(data) {\n        console.log(data)  //change\n    },\n    handleSelect(data) {\n        console.log(data)  //select\n    },\n}\n\n//子级组件\n&lt;other v-on=\"$listeners\" @load=\"handleLoad\"&gt;&lt;/other&gt;\nmethods: {\n    handleLoad(data) {\n        console.log(data); //load\n    }\n}\n//other组件中\nthis.$emit(\'change\', \'change\');\nthis.$emit(\'select\', \'select\');\nthis.$emit(\'load\', \'load\')\n</code></pre>\n<h2 id=\"dnexttick\">$nextTick</h2>\n<p>$nextTick是在下一次在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。通常用于获取页面中的DOM元素是使用。</p>\n<pre><code class=\"JavaScript language-JavaScript\">this.$nextTick(()=&gt;{\n    // 获取更新后的DOM\n})\n\nthis.$nextTick()\n    .then(()=&gt;{\n        //获取更新后的DOM\n    })\n</code></pre>', '## $set\n参数说明\n```JavaScript\n{Object | Array} target\n{string | number} propertyName/index\n{any} value\n```\n众所周知，vue2的数据响应式系统主要基于`Object.defineProperty`方法来实现，基于数据生成虚拟DOM，当Watcher监测到数据变化时，比较更新虚拟DOM，从而实现页面的变化。但是，对于Watcher监测不到的更新，就无法触发虚拟DOM的比较，因此会出现数据更新，页面没有刷新的现象。例如：给对象中增加属性、通过下标的方式改变数组等，就会出现此问题。\n\n而$set方法就是用来解决上述问题，它会向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。\n```JavaScript\n//操作数组 arr\nthis.$set(this.arr, index, newVal)\n//操作对象obj\nthis.$set(this.obj, newProperty, newVal)\n```\n## $attrs\n$attrs中包含了父级组件中所传递的没有没prop识别的attribute绑定值（除了style和class之外），例如：\n```JavaScript\n//父组件中\n<child title=\"title\" id=\"id\" info=\"info\"></child>\n\n//子组件中的props中只识别了title，因此剩余的id、info绑定值就可以从$attrs中获取\nprops: {\n   title: String\n}\nmounted() {\n   console.log(this.$attrs.id, this.$attrs.info)   //id  info\n}\n```\n$attrs在封装高级组件时是特别好用，例如涉及到多级组件传参在中间组件中用`v-bind=\"$attrs\"`即可把没有被当前prop识别的attribute传递到子级组件中。\n```JavaScript\n//父组件中\n<child title=\"title\" id=\"id\" info=\"info\"></child>\n\n//子级组件\n<other v-bind=\"$attrs\"></other>\nprops: {\n   title: String\n}\n//other组件中\nprops: {\n   id: String, //id\n   info: String //info\n}\n```\n\n## $listeners\n$listeners与$attrs对应，$listeners包含了父级组件中（不含 .native 修饰器的）v-on监听的事件，同样在封装高级组件中特别好用。\n```JavaScript\n//父组件中\n<child @change=\"handleChange\" @select=\"handleSelect\"></child>\n\nmethods: {\n    handleChange(data) {\n        console.log(data)  //change\n    },\n    handleSelect(data) {\n        console.log(data)  //select\n    },\n}\n\n//子级组件\n<other v-on=\"$listeners\" @load=\"handleLoad\"></other>\nmethods: {\n    handleLoad(data) {\n        console.log(data); //load\n    }\n}\n//other组件中\nthis.$emit(\'change\', \'change\');\nthis.$emit(\'select\', \'select\');\nthis.$emit(\'load\', \'load\')\n```\n\n## $nextTick\n$nextTick是在下一次在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。通常用于获取页面中的DOM元素是使用。\n```JavaScript\nthis.$nextTick(()=>{\n    // 获取更新后的DOM\n})\n\nthis.$nextTick()\n    .then(()=>{\n        //获取更新后的DOM\n    })\n```', '5', '1', '1');
INSERT INTO `artical` VALUES (1000052, 'JavaScript | call方法的实现', '2021-02-06 08:59:02', '姚文', 649, 5, 'call方法改变函数执行时作用域this指向的问题', 0, 0, '<pre><code class=\"JavaScript language-JavaScript\">function call (fn, obj, ...args) {\n  if (obj === null || obj === undefined) {\n    obj = globalThis;\n  }\n  obj.temp = fn;\n  let res = obj.temp(...args)\n  delete obj.temp;\n  return res\n}\n</code></pre>\n<p>调用示例：</p>\n<pre><code class=\"javascript language-javascript\">function add() {\n    return this.a + this.b\n}\nvar a=100,b=200;\nvar obj = {\n    a: 1,\n    b: 2\n};\n\nconsole.log(call(add,null)); //300\nconsole.log(call(add,obj)); //3\n</code></pre>', '```JavaScript\nfunction call (fn, obj, ...args) {\n  if (obj === null || obj === undefined) {\n    obj = globalThis;\n  }\n  obj.temp = fn;\n  let res = obj.temp(...args)\n  delete obj.temp;\n  return res\n}\n```\n\n调用示例：\n\n```javascript\nfunction add() {\n	return this.a + this.b\n}\nvar a=100,b=200;\nvar obj = {\n	a: 1,\n	b: 2\n};\n\nconsole.log(call(add,null)); //300\nconsole.log(call(add,obj)); //3\n```', '1', '1', '2');
INSERT INTO `artical` VALUES (1000057, 'JavaScript | apply方法的实现', '2021-02-06 08:53:41', '姚文', 273, 5, '手写实现apply方法', 0, 0, '<pre><code class=\"JavaScript language-JavaScript\">function apply (fn, obj, arguments) {\n  if (obj === null || obj === undefined) {\n    obj = globalThis\n  }\n  obj.temp = fn;\n  let result = obj.temp(...arguments);\n  delete obj.temp\n\n  return result;\n}\n\nfunction add (base) { return this.a + this.b + base }\n\nvar a = 3, b = 9; \nvar obj = { a: 1, b: 2 }\n\nconsole.log(apply(add, null, [100]));//112 \nconsole.log(apply(add, obj, [100]));//103\n</code></pre>', '```JavaScript\nfunction apply (fn, obj, arguments) {\n  if (obj === null || obj === undefined) {\n    obj = globalThis\n  }\n  obj.temp = fn;\n  let result = obj.temp(...arguments);\n  delete obj.temp\n\n  return result;\n}\n\nfunction add (base) { return this.a + this.b + base }\n\nvar a = 3, b = 9; \nvar obj = { a: 1, b: 2 }\n\nconsole.log(apply(add, null, [100]));//112 \nconsole.log(apply(add, obj, [100]));//103\n```', '3', '1', '2');
INSERT INTO `artical` VALUES (1000059, 'JavaScript | bind方法', '2021-02-06 08:53:33', '姚文', 663, 3, 'bind方法改变函数调用时的作用域对象', 0, 0, '<pre><code class=\"javascript language-javascript\">function bind (fn, obj, ...args) {\n  return function (...reset) {\n    if (obj === null || obj === undefined) {\n      obj = globalThis;\n    }\n    obj.temp = fn;\n    let res;\n    if (args.length &gt; 0) {\n      res = obj.temp(...args);\n    } else {\n      res = obj.temp(...reset);\n    }\n    delete obj.temp\n    return res\n  }\n}\n</code></pre>\n<p>\n<strong>参数说明</strong> </p>\n<p><code>fn</code> <code>Function</code>调用的函数 </p>\n<p><code>obj</code> 调用函数的作用域 </p>\n<p><strong>调用示例</strong></p>\n<pre><code class=\"javascript language-javascript\">  function add(base) {\n    return this.a + this.b + base\n  }\n\n  var a = 3, b = 9;\n  var obj = {\n    a: 1, b: 2\n  }\n  console.log(bind(add, obj,100)())\n  console.log(bind(add, obj)(100))\n</code></pre>', '```javascript\nfunction bind (fn, obj, ...args) {\n  return function (...reset) {\n    if (obj === null || obj === undefined) {\n      obj = globalThis;\n    }\n    obj.temp = fn;\n    let res;\n    if (args.length > 0) {\n      res = obj.temp(...args);\n    } else {\n      res = obj.temp(...reset);\n    }\n    delete obj.temp\n    return res\n  }\n}\n``` \n**参数说明** \n\n`fn` `Function`调用的函数 \n\n`obj` 调用函数的作用域 \n\n**调用示例**\n```javascript\n  function add(base) {\n    return this.a + this.b + base\n  }\n\n  var a = 3, b = 9;\n  var obj = {\n    a: 1, b: 2\n  }\n  console.log(bind(add, obj,100)())\n  console.log(bind(add, obj)(100))\n```\n', '3', '1', '2');
INSERT INTO `artical` VALUES (1000060, 'Format | formatDate日期格式转化方法', '2021-02-06 08:54:34', '姚文', 99, 7, '按照指定格式转化日期时间格式', 0, 0, '<p><strong>参数说明<code>Object</code></strong> </p>\n<p><code>date</code>转化的日期，默认当前日期。</p>\n<p><code>format</code>转化后的格式，默认：年-月-日 时:分:秒。</p>\n<p><code>split</code>年月日之间的分隔符，默认为\'-\'。</p>\n<pre><code class=\"javascript language-javascript\">function formatDate ({ date, format = \'YY-MM-DD HH-MM-SS\', split = \'-\' }) {\n\n  const newDate = date ? new Date(date.replace(/-/g, \'/\')) : new Date();\n\n  let yearVal = newDate.getFullYear();\n  let monthVal = newDate.getMonth() + 1 &gt; 9 ? newDate.getMonth() + 1 : \'0\' + (newDate.getMonth() + 1);\n  let dateVal = newDate.getDate() &gt; 9 ? newDate.getDate() : \'0\' + newDate.getDate();\n  let hourVal = newDate.getHours() &gt; 9 ? newDate.getHours() : \'0\' + newDate.getHours();\n  let minuteVal = newDate.getMinutes() &gt; 9 ? newDate.getMinutes() : \'0\' + newDate.getMinutes();\n  let secondVal = newDate.getSeconds() &gt; 9 ? newDate.getSeconds() : \'0\' + newDate.getSeconds();\n\n  const yearMonthDate = yearVal + split + monthVal + split + dateVal;\n  let result;\n  switch (format) {\n    case \'YY-MM-DD HH-MM-SS\':\n      result = yearMonthDate + \' \' + `${hourVal}:${minuteVal}:${secondVal}`\n      break;\n    case \'YY-MM-DD HH-MM\':\n      result = yearMonthDate + \' \' + `${hourVal}:${minuteVal}`\n      break;\n    case \'YY-MM-DD\':\n      result = yearMonthDate;\n      break;\n    case \'YY-MM\':\n      result = yearVal + split + monthVal;\n      break;\n    case \'YY\':\n      result = yearVal;\n      break;\n    case \'MM\':\n      result = monthVal;\n      break;\n    case \'DD\':\n      result = dateVal;\n      break;\n    case \'HH\':\n      result = hourVal;\n      break;\n    case \'mm\':\n      result = minuteVal;\n      break;\n    case \'SS\':\n      result = secondVal;\n      break;\n    case \'HH-MM-SS\':\n      result = `${hourVal}:${minuteVal}:${secondVal}`;\n      break;\n    default:\n      result = yearMonthDate + \' \' + `${hourVal}:${minuteVal}:${secondVal}`\n  }\n  return result\n}\n</code></pre>\n<p><strong>调用示例</strong></p>\n<pre><code class=\"javascript language-javascript\">    console.log(formatDate({ format: \'YY-MM-DD HH-MM\' })); //2020-02-05 15:29\n</code></pre>', '**参数说明`Object`** \n\n`date`转化的日期，默认当前日期。\n\n`format`转化后的格式，默认：年-月-日 时:分:秒。\n\n`split`年月日之间的分隔符，默认为\'-\'。\n\n```javascript\nfunction formatDate ({ date, format = \'YY-MM-DD HH-MM-SS\', split = \'-\' }) {\n\n  const newDate = date ? new Date(date.replace(/-/g, \'/\')) : new Date();\n\n  let yearVal = newDate.getFullYear();\n  let monthVal = newDate.getMonth() + 1 > 9 ? newDate.getMonth() + 1 : \'0\' + (newDate.getMonth() + 1);\n  let dateVal = newDate.getDate() > 9 ? newDate.getDate() : \'0\' + newDate.getDate();\n  let hourVal = newDate.getHours() > 9 ? newDate.getHours() : \'0\' + newDate.getHours();\n  let minuteVal = newDate.getMinutes() > 9 ? newDate.getMinutes() : \'0\' + newDate.getMinutes();\n  let secondVal = newDate.getSeconds() > 9 ? newDate.getSeconds() : \'0\' + newDate.getSeconds();\n\n  const yearMonthDate = yearVal + split + monthVal + split + dateVal;\n  let result;\n  switch (format) {\n    case \'YY-MM-DD HH-MM-SS\':\n      result = yearMonthDate + \' \' + `${hourVal}:${minuteVal}:${secondVal}`\n      break;\n    case \'YY-MM-DD HH-MM\':\n      result = yearMonthDate + \' \' + `${hourVal}:${minuteVal}`\n      break;\n    case \'YY-MM-DD\':\n      result = yearMonthDate;\n      break;\n    case \'YY-MM\':\n      result = yearVal + split + monthVal;\n      break;\n    case \'YY\':\n      result = yearVal;\n      break;\n    case \'MM\':\n      result = monthVal;\n      break;\n    case \'DD\':\n      result = dateVal;\n      break;\n    case \'HH\':\n      result = hourVal;\n      break;\n    case \'mm\':\n      result = minuteVal;\n      break;\n    case \'SS\':\n      result = secondVal;\n      break;\n    case \'HH-MM-SS\':\n      result = `${hourVal}:${minuteVal}:${secondVal}`;\n      break;\n    default:\n      result = yearMonthDate + \' \' + `${hourVal}:${minuteVal}:${secondVal}`\n  }\n  return result\n}\n``` \n\n**调用示例**\n```javascript\n    console.log(formatDate({ format: \'YY-MM-DD HH-MM\' })); //2020-02-05 15:29\n```\n', '3', '1', '2');
INSERT INTO `artical` VALUES (1000066, '五分钟搞懂JS作用域、环境与闭包', '2021-02-05 18:30:50', '姚文', 427, 4, 'js作用域、执行环境与闭包的概念解析。', 0, 0, '<p>作用域与环境：</p>\n<pre><code class=\"javascript language-javascript\">var n=0;\n    function add() {\n        return ++n\n    }\n    var a = add()\n    console.log(a)//?\n    var b = add()\n    console.log(b)//?\n    var c = add()//?\n    console.log(c)//?\n</code></pre>\n<p>答案是：1，2，3</p>\n<p>我们再来稍作改动</p>\n<p>``javascript\n    function add() {\n        var n=0;\n        return ++n\n    }\n    var a = add()\n    console.log(a)//?\n    var b = add()\n    console.log(b)//?\n    var c = add()//?\n    console.log(c)//?\n```\n这个时候的a、b、c分别是什么值呢？\n答案是：1，1，1</p>', '作用域与环境：\n```javascript\n	var n=0;\n	function add() {\n		return ++n\n	}\n	var a = add()\n	console.log(a)//?\n	 var b = add()\n	console.log(b)//?\n	var c = add()//?\n	console.log(c)//?\n```\n答案是：1，2，3\n\n我们再来稍作改动\n\n``javascript\n	function add() {\n		var n=0;\n		return ++n\n	}\n	var a = add()\n	console.log(a)//?\n	var b = add()\n	console.log(b)//?\n	var c = add()//?\n	console.log(c)//?\n```\n这个时候的a、b、c分别是什么值呢？\n答案是：1，1，1\n\n\n\n\n\n\n\n\n', '3', '0', '1');
INSERT INTO `artical` VALUES (1000067, 'Vue ｜ new Vue()时都发生了什么？', '2021-02-06 09:41:19', '姚文', 761, 2, 'new Vue()时都vue都做了哪些事情？', 0, 0, '<p>首次new Vue()时Vue都做了哪些事情？</p>', '首次new Vue()时Vue都做了哪些事情？\n\n', '5', '0', '1');
INSERT INTO `artical` VALUES (1000069, '知识点｜不常用的JavaScript代码片段记录', '2021-02-06 10:43:13', '姚文', 52, 6, '记录不常用的js代码片段', 0, 0, '<h2 id=\"input\">input中监听常用的键盘按键</h2>\n<h3 id=\"ctrls\">监听<code>ctrl+s</code>实现保存功能</h3>\n<p>思路：<code>ctrl+s</code>组合键默认行为是保存当前网页，首先需要阻止默认行为，然后添加要实现保存的方法。注意：<code>window</code>和<code>mac</code>常用的保存按键有些许区别，<code>windows</code>是<code>ctrl+s</code>，而<code>mac</code>为<code>command + s</code>。</p>\n<p>键盘上<code>s</code>的<code>keyCode</code>是83，ctrl和command可以直接用<code>e.ctrlKey</code>、<code>e.metaKey</code>来进行判断。</p>\n<p>代码示例：</p>\n<pre><code class=\"javascript language-javascript\">function autoSaveCode (el, callback) {\n    el.querySelector(\'.edit\').addEventListener(\'keydown\', (e) =&gt; {\n        if ((e.ctrlKey || e.metaKey) &amp;&amp; e.keyCode === 83) {\n            e.preventDefault()\n            callback()\n        }\n    })\n}\n</code></pre>\n<p><code>el</code> 监听区域的dom元素\n<code>callback</code>监听成功的回掉操作</p>', '## input中监听常用的键盘按键\n\n### 监听`ctrl+s`实现保存功能\n\n思路：`ctrl+s`组合键默认行为是保存当前网页，首先需要阻止默认行为，然后添加要实现保存的方法。注意：`window`和`mac`常用的保存按键有些许区别，`windows`是`ctrl+s`，而`mac`为`command + s`。\n\n键盘上`s`的`keyCode`是83，ctrl和command可以直接用`e.ctrlKey`、`e.metaKey`来进行判断。\n\n代码示例：\n\n```javascript\nfunction autoSaveCode (el, callback) {\n	el.querySelector(\'.edit\').addEventListener(\'keydown\', (e) => {\n		if ((e.ctrlKey || e.metaKey) && e.keyCode === 83) {\n			e.preventDefault()\n			callback()\n		}\n	})\n}\n```\n`el` 监听区域的dom元素\n`callback`监听成功的回掉操作', '3', '1', '1');
INSERT INTO `artical` VALUES (1000070, 'JavaScript | throttle截流函数和debounce防抖函数的封装', '2021-02-06 11:54:40', '姚文', 596, 9, 'throttle截流函数和debounce防抖函数的封装', 0, 0, '<p>截流函数：是指在指定时间范围内，只执行一次相同的任务。</p>\n<p>防抖函数：任务频繁触发的情况下，只有任务触发的时间间隔超过指定的时间间隔，才会执行。</p>\n<h2 id=\"throttle\">截留函数（throttle）</h2>\n<p>适用场景：</p>\n<p>1、监听鼠标滚动事件，调用接口</p>\n<p>2、用户点击刷新验证码操作</p>\n<pre><code class=\"javascript language-javascript\">function throttle (fn, delay) {\n    let isDo = true\n    return function (...args) {\n        if (!isDo) return\n        isDo = false\n        fn.call(this, ...args)\n        setTimeout(() =&gt; {\n            isDo = true\n        }, delay)\n    }\n}\n\nwindow.addEventListener(\'scroll\', throttle((e) =&gt; {\n    console.log(e);\n}, 3000))\n</code></pre>\n<h2 id=\"debounce\">防抖函数（debounce）</h2>\n<p>适用场景：</p>\n<p>1、监听input输入字段进行模糊搜索匹配</p>\n<p>2、浏览器窗口大小改变切换</p>\n<pre><code class=\"javascript language-javascript\">  &lt;input type=\"text\"&gt;\n  &lt;script&gt;\n    function debounce(fn, delay) {\n        let timer;\n         return function (...args) {\n            if (timer) clearTimeout(timer)\n            timer = setTimeout(() =&gt; {\n                fn.call(this, ...args)\n                clearTimeout(timer)\n            }, delay)\n        }\n    }\n    document.querySelector(\'input\').addEventListener(\'input\', debounce((e) =&gt; {\n         console.log(e);\n    }, 1000))\n&lt;/script&gt;\n</code></pre>', '截流函数：是指在指定时间范围内，只执行一次相同的任务。\n\n防抖函数：任务频繁触发的情况下，只有任务触发的时间间隔超过指定的时间间隔，才会执行。\n\n## 截留函数（throttle）\n\n适用场景：\n\n1、监听鼠标滚动事件，调用接口\n\n2、用户点击刷新验证码操作\n\n```javascript\nfunction throttle (fn, delay) {\n	let isDo = true\n	return function (...args) {\n		if (!isDo) return\n		isDo = false\n		fn.call(this, ...args)\n		setTimeout(() => {\n			isDo = true\n		}, delay)\n	}\n}\n\nwindow.addEventListener(\'scroll\', throttle((e) => {\n	console.log(e);\n}, 3000))\n```\n\n## 防抖函数（debounce）\n\n适用场景：\n\n1、监听input输入字段进行模糊搜索匹配\n\n2、浏览器窗口大小改变切换\n\n\n```javascript\n  <input type=\"text\">\n  <script>\n	function debounce(fn, delay) {\n		let timer;\n		 return function (...args) {\n			if (timer) clearTimeout(timer)\n			timer = setTimeout(() => {\n				fn.call(this, ...args)\n				clearTimeout(timer)\n			}, delay)\n		}\n	}\n	document.querySelector(\'input\').addEventListener(\'input\', debounce((e) => {\n		 console.log(e);\n	}, 1000))\n</script>\n```', '3', '1', '1');
INSERT INTO `artical` VALUES (1000075, 'Vue ｜ vue项目webpack打包优化策略', '2021-02-06 16:36:22', '姚文', 77, 4, '对于vendors包过大的情况，采用分离第三方包、cdn引入资源的方式，减少vendors包的体积，优化vue项目运行时性能。', 0, 0, '<p>SPA单页面应用首次加载时，会加载所有的依赖资源（js、css..）。当打包后的文件体积过大时，首次加载会慢很多，影响用户体验。</p>\n<p>加载速度这个问题，有很多可以优化的方向，除了编码时的优化之外，这篇文章记录一下利用<code>webpack</code>打包配置，来优化打包生成的文件体积。主要从两个方向来优化：<code>cdn</code>引入资源和拆分公共<code>vendor</code>包。</p>\n<h2 id=\"cdn\">第三方资源cdn引入配置</h2>\n<p>第三方资源，即项目中用到的第三方插件，例如：<code>elment-ui</code>、<code>vue-router</code>、<code>vuex</code>、<code>axios</code>等。将第三方资源通过cdn引入的方式从index.html中引入，而不是打包到我们的项目代码中，会减少项目js代码的体积，提高加载速度。此配置需要在<code>vue.config.js</code>中的<code>configureWebpack</code>&gt;<code>externals</code>中进行配置，<code>externals</code>是一个对象，<code>key</code>    为第三方包的名称，<code>value</code>值为第三方包打包后导出的对象名称（可以去第三方包中的dist文件中查找），例如：import Vue from \'vue\'，在此即可配置为：<code>vue: \'Vue\'</code>，vue为第三方包的名称，Vue为vue打包后导出供我们使用的名称。</p>\n<p><code>vue.config.js</code></p>\n<pre><code class=\"javascript language-javascript\">module.exports = {\n    //......省略其他配置\n    configureWebpack: config =&gt; {\n        config.externals = {\n            vue: \"Vue\", //第三方资源名称：\n            \"vue-router\": \"VueRouter\",\n            vuex: \"Vuex\",\n            \'axios\': \'axios\'\n        }\n    }\n}\n</code></pre>\n<p><code>index.html</code></p>\n<pre><code class=\"html language-html\">&lt;head&gt;\n    &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vue/3.0.0/vue.global.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vuex/4.0.0-rc.1/vuex.global.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/vue-router/4.0.0-rc.1/vue-router.global.min.js\"&gt;&lt;/script&gt;\n    &lt;script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.21.0/axios.min.js\"&gt;&lt;/script&gt;\n&lt;/head&gt;\n</code></pre>\n<p>需要注意的是：在从cdn引入时，记得引入你项目中所用的<strong>相同版本</strong>的包。</p>\n<p>另外推荐一个比较好用的cdn网站：<a href=\"https://www.bootcdn.cn/\">BootCDN-稳定、快速、免费的前端开源项目 CDN 加速服务</a></p>\n<h2 id=\"vendor\">拆分<code>vendor</code>包</h2>\n<p>拆分<code>vendor</code>包即将第三方包分离出单独的包文件，降低<code>vendor</code>包的体积。需要在<code>vue.config.js</code>中的<code>configureWebpack</code>&gt;<code>optimization</code>中进行配置：</p>\n<pre><code>module.exports = {\n    //......省略其他配置\n    configureWebpack: config =&gt; {\n        config.externals = {\n            vue: \"Vue\", //第三方资源名称：\n            \"vue-router\": \"VueRouter\",\n            vuex: \"Vuex\",\n            \'axios\': \'axios\'\n        }\n        splitChunks: {\n            chunks: \'all\',\n            cacheGroups: {\n                \'element-plus\': {\n                    name: \'element-plus\',\n                    test: /[\\\\/]node_modules[\\\\/]element-plus[\\\\/]/,\n                    priority: -10\n                },\n                \'vendors\': {\n                    name: \'vendors\',\n                    test: /[\\\\/]node_modules[\\\\/]/,\n                    priority: -20\n                },\n            }\n        }\n    }\n}\n</code></pre>\n<p>其中name是指定打包之后的bundle文件名，test则是匹配需要分离的第三方库所在的目录，priority指定打包的优先级，这个值必须要比vendors的打包优先级大，不然便无法成功分离指定的第三方库，仍然会被打包到vendors中。</p>\n<h2 id=\"\">总结</h2>\n<p>以上就是两种用来优化vue打包优化的思路方法，除此之外，项目性能还可以从以下思路进行优化：</p>\n<p>1、减少<code>data</code>中的数据，及时删除没用的数据，因为<code>data</code>中的数据每一个都会增加<code>getter</code>和<code>setter</code>，收集对应的<code>watcher</code>，无用的数据浪费性能。</p>\n<p>2、避免<code>v-for</code>和<code>v-if</code>混合使用，因为在<code>vue2</code>中<code>v-for</code>的优先级比<code>v-if</code>的优先级要高，即不管判断条件是否为真，都会先进行一遍渲染，浪费性能。（备注：vue3中v-if的优先级会大于v-for的优先级）</p>\n<p>3、<code>key</code>值保证唯一。</p>\n<p>4、使用截流和防抖，减少服务端请求次数<a href=\"http://42.192.140.201/artical/detail?articalid=1000070\">封装截流和防抖函数</a>。</p>\n<p>5、第三方模块按需导入，不要全部引入。</p>\n<p>6、长列表分页加载，滚动到可视区域再加载。</p>\n<p>7、如果网站需要SEO搜索，采用服务端SSR渲染、预渲染。</p>', 'SPA单页面应用首次加载时，会加载所有的依赖资源（js、css..）。当打包后的文件体积过大时，首次加载会慢很多，影响用户体验。\n\n加载速度这个问题，有很多可以优化的方向，除了编码时的优化之外，这篇文章记录一下利用`webpack`打包配置，来优化打包生成的文件体积。主要从两个方向来优化：`cdn`引入资源和拆分公共`vendor`包。\n\n## 第三方资源cdn引入配置\n\n第三方资源，即项目中用到的第三方插件，例如：`elment-ui`、`vue-router`、`vuex`、`axios`等。将第三方资源通过cdn引入的方式从index.html中引入，而不是打包到我们的项目代码中，会减少项目js代码的体积，提高加载速度。此配置需要在`vue.config.js`中的`configureWebpack`>`externals`中进行配置，`externals`是一个对象，`key`	为第三方包的名称，`value`值为第三方包打包后导出的对象名称（可以去第三方包中的dist文件中查找），例如：import Vue from \'vue\'，在此即可配置为：`vue: \'Vue\'`，vue为第三方包的名称，Vue为vue打包后导出供我们使用的名称。\n\n`vue.config.js`\n\n```javascript\nmodule.exports = {\n	//......省略其他配置\n	configureWebpack: config => {\n		config.externals = {\n			vue: \"Vue\", //第三方资源名称：\n			\"vue-router\": \"VueRouter\",\n			vuex: \"Vuex\",\n			\'axios\': \'axios\'\n		}\n	}\n}\n```\n\n`index.html`\n\n```html\n<head>\n	<script src=\"https://cdn.bootcdn.net/ajax/libs/vue/3.0.0/vue.global.js\"></script>\n	<script src=\"https://cdn.bootcdn.net/ajax/libs/vuex/4.0.0-rc.1/vuex.global.min.js\"></script>\n	<script src=\"https://cdn.bootcdn.net/ajax/libs/vue-router/4.0.0-rc.1/vue-router.global.min.js\"></script>\n	<script src=\"https://cdn.bootcdn.net/ajax/libs/axios/0.21.0/axios.min.js\"></script>\n</head>\n```\n\n需要注意的是：在从cdn引入时，记得引入你项目中所用的**相同版本**的包。\n\n另外推荐一个比较好用的cdn网站：[BootCDN-稳定、快速、免费的前端开源项目 CDN 加速服务](https://www.bootcdn.cn/)\n\n## 拆分`vendor`包\n\n拆分`vendor`包即将第三方包分离出单独的包文件，降低`vendor`包的体积。需要在`vue.config.js`中的`configureWebpack`>`optimization`中进行配置：\n\n```\nmodule.exports = {\n	//......省略其他配置\n	configureWebpack: config => {\n		config.externals = {\n			vue: \"Vue\", //第三方资源名称：\n			\"vue-router\": \"VueRouter\",\n			vuex: \"Vuex\",\n			\'axios\': \'axios\'\n		}\n		splitChunks: {\n			chunks: \'all\',\n			cacheGroups: {\n				\'element-plus\': {\n					name: \'element-plus\',\n					test: /[\\\\/]node_modules[\\\\/]element-plus[\\\\/]/,\n					priority: -10\n				},\n				\'vendors\': {\n					name: \'vendors\',\n					test: /[\\\\/]node_modules[\\\\/]/,\n					priority: -20\n				},\n			}\n		}\n	}\n}\n```\n\n其中name是指定打包之后的bundle文件名，test则是匹配需要分离的第三方库所在的目录，priority指定打包的优先级，这个值必须要比vendors的打包优先级大，不然便无法成功分离指定的第三方库，仍然会被打包到vendors中。\n\n\n## 总结\n\n以上就是两种用来优化vue打包优化的思路方法，除此之外，项目性能还可以从以下思路进行优化：\n\n1、减少`data`中的数据，及时删除没用的数据，因为`data`中的数据每一个都会增加`getter`和`setter`，收集对应的`watcher`，无用的数据浪费性能。\n\n2、避免`v-for`和`v-if`混合使用，因为在`vue2`中`v-for`的优先级比`v-if`的优先级要高，即不管判断条件是否为真，都会先进行一遍渲染，浪费性能。（备注：vue3中v-if的优先级会大于v-for的优先级）\n\n3、`key`值保证唯一。\n\n4、使用截流和防抖，减少服务端请求次数[封装截流和防抖函数](http://42.192.140.201/artical/detail?articalid=1000070)。\n\n5、第三方模块按需导入，不要全部引入。\n\n6、长列表分页加载，滚动到可视区域再加载。\n\n7、如果网站需要SEO搜索，采用服务端SSR渲染、预渲染。\n', '5', '1', '1');
INSERT INTO `artical` VALUES (1000076, 'Vue3 ｜ vue3中composition API的使用', '2021-02-07 18:41:51', '姚文', 784, 3, 'vue3中composition API的使用', 0, 0, '<p>Vue3一个重大的升级就是composition API，今天，就来简单介绍一下composition API能帮助我们干什么？</p>\n<p>假定现在有这样一个需求：</p>\n<blockquote>\n  <p>现在有三个页面要分别展示不同状态的商品列表，</p>\n</blockquote>\n<p>这样的需求可以说是</p>', 'Vue3一个重大的升级就是composition API，今天，就来简单介绍一下composition API能帮助我们干什么？\n\n假定现在有这样一个需求：\n\n> 现在有三个页面要分别展示不同状态的商品列表，\n\n这样的需求可以说是', '3', '0', '1');
INSERT INTO `artical` VALUES (1000077, 'Proxy | ES 6 Proxy实现对象代理，实现简单的数据响应式变化视图更新', '2021-02-08 11:39:15', '姚文', 627, 7, 'Vue3中利用Proxy代替了vue2中Object.defineProperty()方法来实现响应式数据，本篇文章简单介绍Proxy用法，实现一个数据和视图响应式更新的Demo。', 0, 0, '<p><code>vue2</code>的数据响应式是利用<code>Object.defineProperty()</code>来实现，在<code>set</code>和<code>get</code>中，创建依赖、收集依赖，当数据变化时，<code>Watcher</code>再去通知该数据所依赖的地方，进行数据响应式更新。<code>Object.defineProperty()</code>无法监听到对象上的新增属性和删除属性，因此<code>vue2</code>中，对象新增和删除的属性都需要调用<code>$set</code>方法，从而手动的执行创建依赖、收集依赖…等过程。</p>\n<p>而<code>Vue3</code>中使用了<code>ES 6</code>中新提供的<code>Proxy</code>代理，来实现数据响应式，MDN上是这样来定义<code>Proxy</code>的：</p>\n<blockquote>\n  <p>Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p>\n</blockquote>\n<p>换句话说，<code>Proxy</code>对象能够包装你的目标对象，并且可以拦截到对该对象进行数据操作。<code>Proxy</code>接受两个参数：</p>\n<p><code>const obj = new Proxy(target, handler)</code></p>\n<ul>\n<li><p><code>target</code> 要使用 <code>Proxy</code> 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。</p></li>\n<li><p><code>handler</code> 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 <code>obj</code> 的行为。</p></li>\n</ul>\n<p><code>handler</code>对象常用的方法有：</p>\n<pre><code>* `handler.get()` 属性读取操作的捕捉器。\n* `handler.set()` 属性设置操作的捕捉器。\n* `handler.deleteProperty()` delete 操作符的捕捉器。\n* `handler.apply()` 函数调用操作的捕捉器。\n* `handler.has()` in 操作符的捕捉器。\n</code></pre>\n<p>详细的<code>Proxy</code>文档介绍，可查阅<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\">MDN Proxy</a></p>\n<p>先用<code>Proxy</code>包装一个简单的对象，实现读取、新增、删除属性的拦截：</p>\n<pre><code class=\"javascript language-javascript\">const obj = {\n    name: \'curry\',\n    age: 34\n}\nconst handler = {\n    get(target, key) {\n        const result = Reflect.get(target, key)\n        console.log(\'读取数据\', key)\n        return result\n    },\n    set(target, key, val) {\n        const result = Reflect.set(target, key, val)\n        console.log(\'写入数据\', key)\n        return result\n    },\n    deleteProperty(target, key, val) {\n        const result = Reflect.deleteProperty(target, key)\n        console.log(\'删除数据\', key)\n        return result\n    },\n}\n\n//用new Proxy()生成一个代理的对象\nconst  proxyObj = new Proxy(obj, handler)\n\n//访问name属性\nproxyObj.name //控制台打印：读取数据 name\nproxyObj.team = \'GSW\' //控制台打印：写入数据 team\ndelete proxyObj.age //控制台打印：删除数据 age\n</code></pre>\n<p><code>console.log(proxyObj)</code></p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afacf7f67dac41c3bb5153ca7baba316~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<p>可以看到，我们对于<code>proxyObj</code>的读、写操作，甚至<code>delete</code>都可以拦截到，这是<code>Object.defineProperty()</code>所不能实现的。</p>\n<p>拦截到数据读取操作之后，利用数据的变化，来实现页面的更新。接下来就写一个简单的例子：定义一个<code>counter</code>，counter1秒钟增加一次，并且把增加后的值同时显示在页面上。</p>\n<pre><code class=\"html language-html\">&lt;div id=\"app\"&gt;&lt;/div&gt;\n</code></pre>\n<pre><code class=\"javascript language-javascript\">const obj = { counter: 1 }\nconst handler = {\n  get(target, key) {\n    const result = Reflect.get(target, key)\n    console.log(\'读取数据\', key)\n    return result\n  },\n  set(target, key, val) {\n    const result = Reflect.set(target, key, val)\n    console.log(\'写入数据\', key)\n    updateHtml()\n    return result\n  },\n  deleteProperty(target, key, val) {\n    const result = Reflect.deleteProperty(target, key)\n    console.log(\'删除数据\', key)\n    return result\n  },\n}\n\nconst proxyObj = new Proxy(obj, handler)\n\nconst app = document.getElementById(\'app\');\n\nsetInterval(() =&gt; {\n  proxyObj.counter++\n}, 1000);\n\nfunction updateHtml() {\n  app.innerHTML = obj.counter\n}\n</code></pre>\n<p>实现效果：</p>\n<p><img src=\"https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0a932cb6bc84034a975134a766259fa~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<p>可以看到<code>counter</code>每次变化之后，都会去执行<code>updateHtml</code>方法，从而实现视图的更新，<code>vue3</code>的响应式基本原理大概就是如此，vue会在数据更新的时候，在<code>updateHtml</code>中进行更多的操作，例如：<code>diff</code>算法比较<code>VNode</code>，从而实现差量更新，节省<code>DOM</code>操作性能等。</p>', '`vue2`的数据响应式是利用`Object.defineProperty()`来实现，在`set`和`get`中，创建依赖、收集依赖，当数据变化时，`Watcher`再去通知该数据所依赖的地方，进行数据响应式更新。`Object.defineProperty()`无法监听到对象上的新增属性和删除属性，因此`vue2`中，对象新增和删除的属性都需要调用`$set`方法，从而手动的执行创建依赖、收集依赖...等过程。\n\n而`Vue3`中使用了`ES 6`中新提供的`Proxy`代理，来实现数据响应式，MDN上是这样来定义`Proxy`的：\n\n> Proxy 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。\n\n换句话说，`Proxy`对象能够包装你的目标对象，并且可以拦截到对该对象进行数据操作。`Proxy`接受两个参数：\n\n`const obj = new Proxy(target, handler)`\n\n* `target` 要使用 `Proxy` 包装的目标对象（可以是任何类型的对象，包括原生数组，函数，甚至另一个代理）。\n\n* `handler` 一个通常以函数作为属性的对象，各属性中的函数分别定义了在执行各种操作时代理 `obj` 的行为。\n\n`handler`对象常用的方法有：\n\n	* `handler.get()` 属性读取操作的捕捉器。\n	* `handler.set()` 属性设置操作的捕捉器。\n	* `handler.deleteProperty()` delete 操作符的捕捉器。\n	* `handler.apply()` 函数调用操作的捕捉器。\n	* `handler.has()` in 操作符的捕捉器。\n\n详细的`Proxy`文档介绍，可查阅[MDN Proxy](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy)\n\n先用`Proxy`包装一个简单的对象，实现读取、新增、删除属性的拦截：\n\n```javascript\nconst obj = {\n	name: \'curry\',\n	age: 34\n}\nconst handler = {\n	get(target, key) {\n		const result = Reflect.get(target, key)\n		console.log(\'读取数据\', key)\n		return result\n	},\n	set(target, key, val) {\n		const result = Reflect.set(target, key, val)\n		console.log(\'写入数据\', key)\n		return result\n	},\n	deleteProperty(target, key, val) {\n		const result = Reflect.deleteProperty(target, key)\n		console.log(\'删除数据\', key)\n		return result\n	},\n}\n\n//用new Proxy()生成一个代理的对象\nconst  proxyObj = new Proxy(obj, handler)\n\n//访问name属性\nproxyObj.name //控制台打印：读取数据 name\nproxyObj.team = \'GSW\' //控制台打印：写入数据 team\ndelete proxyObj.age //控制台打印：删除数据 age\n```\n\n`console.log(proxyObj)`\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/afacf7f67dac41c3bb5153ca7baba316~tplv-k3u1fbpfcp-watermark.image)\n\n可以看到，我们对于`proxyObj`的读、写操作，甚至`delete`都可以拦截到，这是`Object.defineProperty()`所不能实现的。\n\n拦截到数据读取操作之后，利用数据的变化，来实现页面的更新。接下来就写一个简单的例子：定义一个`counter`，counter1秒钟增加一次，并且把增加后的值同时显示在页面上。\n\n```html\n<div id=\"app\"></div>\n```\n\n```javascript\nconst obj = { counter: 1 }\nconst handler = {\n  get(target, key) {\n    const result = Reflect.get(target, key)\n    console.log(\'读取数据\', key)\n    return result\n  },\n  set(target, key, val) {\n    const result = Reflect.set(target, key, val)\n    console.log(\'写入数据\', key)\n    updateHtml()\n    return result\n  },\n  deleteProperty(target, key, val) {\n    const result = Reflect.deleteProperty(target, key)\n    console.log(\'删除数据\', key)\n    return result\n  },\n}\n\nconst proxyObj = new Proxy(obj, handler)\n\nconst app = document.getElementById(\'app\');\n\nsetInterval(() => {\n  proxyObj.counter++\n}, 1000);\n\nfunction updateHtml() {\n  app.innerHTML = obj.counter\n}\n```\n\n实现效果：\n\n![](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e0a932cb6bc84034a975134a766259fa~tplv-k3u1fbpfcp-watermark.image)\n\n\n可以看到`counter`每次变化之后，都会去执行`updateHtml`方法，从而实现视图的更新，`vue3`的响应式基本原理大概就是如此，vue会在数据更新的时候，在`updateHtml`中进行更多的操作，例如：`diff`算法比较`VNode`，从而实现差量更新，节省`DOM`操作性能等。', '5', '1', '1');
INSERT INTO `artical` VALUES (1000078, '创建一个页面消失提示Message，使用函数方法调用', '2021-03-13 20:12:37', '姚文', 550, 8, '创建一个Message类，函数调用。', 0, 0, '<h2 id=\"message\">创建一个Message类</h2>\n<pre><code class=\"javascript language-javascript\">class Message {\n  constructor(options) {\n    const defaultOption = {\n      message: \'\',\n      type: \'success\',\n      duration: 5000\n    }\n    this.options = Object.assign(defaultOption, options)\n\n    if (!document.getElementById(\'messageParent\')) {\n      this.messageParent = document.createElement(\'div\')\n    } else {\n      this.messageParent = document.getElementById(\'messageParent\')\n    }\n\n    this.messageBox = document.createElement(\'div\')\n    this.messageInfo = document.createElement(\'div\')\n    this.closeBtn = document.createElement(\'b\')\n    this.bindEvent()\n\n    this.timer = setTimeout(() =&gt; {\n      this.hide()\n      clearTimeout(this.timer)\n    }, this.options.duration)\n\n  }\n  show () {\n    this.init()\n    this.mount()\n  }\n  hide () {\n    this.messageParent.removeChild(this.messageBox)\n    clearTimeout(this.timer)\n\n    this.checkHasMessageList() ? false : document.body.removeChild(this.messageParent)\n  }\n\n  checkHasMessageList () {\n    const messageList = [...document.querySelectorAll(\'.message\')]\n    if (messageList.length &lt; 1) {\n      return false\n    } else {\n      return true\n    }\n  }\n\n  bindEvent () {\n    this.closeBtn.addEventListener(\'click\', this.hide.bind(this))\n  }\n\n  init () {\n    const messageParentStyle = {\n      position: \'fixed\',\n      left: \'50%\',\n      top: 0\n    }\n\n    for (let key in messageParentStyle) {\n      this.messageParent.style[key] = messageParentStyle[key]\n    }\n\n    this.messageParent.id = \'messageParent\'\n    this.closeBtn.innerHTML = \'X\'\n    this.messageInfo.innerHTML = this.options.message\n\n    this.closeBtn.style.cursor = \'pointer\'\n    this.closeBtn.style.marginLeft = \'10px\'\n\n\n    const messageBoxStyle = {\n      width: \'400px\',\n      margin: \'0 0 10px -200px\',\n      padding: \'10px\',\n      display: \'flex\',\n      justifyContent: \'space-between\',\n      alignItems: \'center\',\n      fontSize: \'14px\',\n      border: \'1px solid #e0e0e0\',\n      color: this.options.type === \'success\' ? \'rgb(100, 194, 70)\' : \'rgb(247, 108, 109)\',\n      backgroundColor: this.options.type === \'success\' ? \'rgb(240, 249, 235)\' : \'rgb(254, 240, 240)\',\n      borderRadius: \'5px\'\n    }\n\n    this.messageBox.className = \'message\'\n\n    for (let key in messageBoxStyle) {\n      this.messageBox.style[key] = messageBoxStyle[key]\n    }\n  }\n  mount () {\n    this.messageBox.appendChild(this.messageInfo)\n    this.messageBox.appendChild(this.closeBtn)\n    document.body.appendChild(this.messageParent)\n    this.messageParent.appendChild(this.messageBox)\n  }\n}\n</code></pre>\n<p>导出一个创建消息提示框的方法，在使用的地方直接使用此方法即可：</p>\n<pre><code class=\"javascript language-javascript\">function createMessage (options = {}) {\n  const message = new Message(options)\n  message.show()\n  return message\n}\n\n//export default createMessage\n//module.exports = createMessage\n</code></pre>\n<p>页面中使用示例：</p>\n<pre><code class=\"html language-html\">&lt;button onclick=\"successMessage()\"&gt;成功消息&lt;/button&gt;\n&lt;button onclick=\"errorMessage()\"&gt;错误消息&lt;/button&gt;\n\n&lt;script&gt;\n  function successMessage() {\n    const number = Math.random()\n    createMessage({\n      message: `我是${number}成功消息`,\n      duration: 3000,\n      type: \'success\'\n    })\n  }\n  function errorMessage() {\n    const number = Math.random()\n    createMessage({\n      message: `我是${number}失败消息`,\n      duration: 5000,\n      type: \'error\'\n    })\n  }\n&lt;/script&gt;\n</code></pre>\n<p>效果图预览：</p>\n<p><img src=\"https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f15fb09d16c549baa962793227bef32b~tplv-k3u1fbpfcp-watermark.image\" alt=\"\" /></p>\n<p><a href=\"https://github.com/yaowencurry/common-function-template/blob/main/message.js\">源码地址github</a></p>', '## 创建一个Message类\n\n```javascript\nclass Message {\n  constructor(options) {\n    const defaultOption = {\n      message: \'\',\n      type: \'success\',\n      duration: 5000\n    }\n    this.options = Object.assign(defaultOption, options)\n    \n    if (!document.getElementById(\'messageParent\')) {\n      this.messageParent = document.createElement(\'div\')\n    } else {\n      this.messageParent = document.getElementById(\'messageParent\')\n    }\n\n    this.messageBox = document.createElement(\'div\')\n    this.messageInfo = document.createElement(\'div\')\n    this.closeBtn = document.createElement(\'b\')\n    this.bindEvent()\n\n    this.timer = setTimeout(() => {\n      this.hide()\n      clearTimeout(this.timer)\n    }, this.options.duration)\n\n  }\n  show () {\n    this.init()\n    this.mount()\n  }\n  hide () {\n    this.messageParent.removeChild(this.messageBox)\n    clearTimeout(this.timer)\n\n    this.checkHasMessageList() ? false : document.body.removeChild(this.messageParent)\n  }\n\n  checkHasMessageList () {\n    const messageList = [...document.querySelectorAll(\'.message\')]\n    if (messageList.length < 1) {\n      return false\n    } else {\n      return true\n    }\n  }\n\n  bindEvent () {\n    this.closeBtn.addEventListener(\'click\', this.hide.bind(this))\n  }\n\n  init () {\n    const messageParentStyle = {\n      position: \'fixed\',\n      left: \'50%\',\n      top: 0\n    }\n\n    for (let key in messageParentStyle) {\n      this.messageParent.style[key] = messageParentStyle[key]\n    }\n\n    this.messageParent.id = \'messageParent\'\n    this.closeBtn.innerHTML = \'X\'\n    this.messageInfo.innerHTML = this.options.message\n\n    this.closeBtn.style.cursor = \'pointer\'\n    this.closeBtn.style.marginLeft = \'10px\'\n\n\n    const messageBoxStyle = {\n      width: \'400px\',\n      margin: \'0 0 10px -200px\',\n      padding: \'10px\',\n      display: \'flex\',\n      justifyContent: \'space-between\',\n      alignItems: \'center\',\n      fontSize: \'14px\',\n      border: \'1px solid #e0e0e0\',\n      color: this.options.type === \'success\' ? \'rgb(100, 194, 70)\' : \'rgb(247, 108, 109)\',\n      backgroundColor: this.options.type === \'success\' ? \'rgb(240, 249, 235)\' : \'rgb(254, 240, 240)\',\n      borderRadius: \'5px\'\n    }\n\n    this.messageBox.className = \'message\'\n\n    for (let key in messageBoxStyle) {\n      this.messageBox.style[key] = messageBoxStyle[key]\n    }\n  }\n  mount () {\n    this.messageBox.appendChild(this.messageInfo)\n    this.messageBox.appendChild(this.closeBtn)\n    document.body.appendChild(this.messageParent)\n    this.messageParent.appendChild(this.messageBox)\n  }\n}\n``` \n\n导出一个创建消息提示框的方法，在使用的地方直接使用此方法即可：\n\n```javascript\nfunction createMessage (options = {}) {\n  const message = new Message(options)\n  message.show()\n  return message\n}\n\n//export default createMessage\n//module.exports = createMessage\n```\n\n页面中使用示例：\n\n```html\n<button onclick=\"successMessage()\">成功消息</button>\n<button onclick=\"errorMessage()\">错误消息</button>\n\n<script>\n  function successMessage() {\n    const number = Math.random()\n    createMessage({\n      message: `我是${number}成功消息`,\n      duration: 3000,\n      type: \'success\'\n    })\n  }\n  function errorMessage() {\n    const number = Math.random()\n    createMessage({\n      message: `我是${number}失败消息`,\n      duration: 5000,\n      type: \'error\'\n    })\n  }\n</script>\n```\n\n效果图预览：\n\n![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f15fb09d16c549baa962793227bef32b~tplv-k3u1fbpfcp-watermark.image)\n\n[源码地址github](https://github.com/yaowencurry/common-function-template/blob/main/message.js)', '3', '1', '1');
INSERT INTO `artical` VALUES (1000079, '创建一个页面提示框，使用函数方法调用', '2021-03-13 20:13:32', '姚文', 471, 3, '这是一个页面常用弹出框提示的class类，使用函数的方法调用，并支持传入确认和关闭的回调函数success、fail以及自定义样式等。\n', 0, 0, '<p>这是一个页面常用弹出框提示的class类，使用函数的方法调用，并支持传入确认和关闭的回调函数success、fail以及自定义样式等。</p>\n<pre><code class=\"javascript language-javascript\">class Alert {\n      constructor(data) {\n        this.data = data\n      }\n      init() {\n        this.createBackgroundBox()\n        this.initALertParent()\n        this.createBtns()\n        this.createTitleBox()\n        this.initContent()\n        this.mount()\n        this.bindEvent()\n        document.body.appendChild(this.bgBox)\n      }\n      mount() {\n        this.parent.appendChild(this.title)\n        this.parent.appendChild(this.content)\n        this.btnBox.appendChild(this.closeBtn)\n        this.btnBox.appendChild(this.confirmBtn)\n        this.parent.appendChild(this.btnBox)\n        this.bgBox.appendChild(this.parent)\n      }\n      bindEvent() {\n        this.confirmBtn.onclick = this.data.success || this.close\n        this.closeBtn.onclick = this.data.fail || this.close\n      }\n      createBtns() {\n        const btnDiv = document.createElement(\'div\')\n        btnDiv.style.height = \'50px\'\n        btnDiv.style.lineHeight = \'1\'\n        btnDiv.style.display = \'flex\'\n        btnDiv.style.justifyContent = \'center\'\n        btnDiv.style.alignItems = \'center\'\n        btnDiv.style.borderTop = \'1px solid #e0e0e0\'\n\n        const closeBtn = document.createElement(\'a\')\n        closeBtn.innerHTML = this.data.closeText || \'关闭\'\n        closeBtn.className = this.data.closeClassName || \'close-btn\'\n        this.setBtnStyle(closeBtn)\n\n        const confirmBtn = document.createElement(\'a\')\n        confirmBtn.className = this.data.confirmClassName || \'submit-btn\'\n        confirmBtn.innerHTML = this.data.confirmText || \'确认\'\n        this.setBtnStyle(confirmBtn)\n\n        this.closeBtn = closeBtn\n        this.confirmBtn = confirmBtn\n        this.btnBox = btnDiv\n      }\n      setBtnStyle(btn) {\n        btn.style.display = \'inline-block\'\n        btn.style.padding = \'10px\'\n      }\n      initContent() {\n        const content = document.createElement(\'p\')\n        content.innerHTML = this.data.content || \'\'\n        const defaultStyle = {\n          height: `calc(${this.data.height} - 118px)`,\n          textAlign: \'left\',\n          padding: \'10px\',\n          overflow: \'auto\'\n        }\n        const contentStyle = Object.assign({}, defaultStyle, this.data.contentStyle)\n        for (let key in contentStyle) {\n          content.style[key] = contentStyle[key]\n        }\n        content.className = this.data.contentClassName || \'dialog-content\'\n        this.content = content\n      }\n      initALertParent() {\n        const parent = document.createElement(\'div\')\n        const defaultStyle = {\n          position: \'absolute\',\n          top: \'50%\',\n          left: \'50%\',\n          transform: \'translateX(-50%) translateY(-50%)\',\n          width: this.data.width || \'700px\',\n          height: this.data.height || \'400px\',\n          backgroundColor: \'#fff\',\n        }\n\n        const parentStyle = Object.assign({}, defaultStyle, this.data.parentStyle)\n        for (let key in parentStyle) {\n          parent.style[key] = parentStyle[key]\n        }\n\n        this.parent = parent\n      }\n      createTitleBox() {\n        const title = document.createElement(\'div\')\n        title.innerHTML = this.data.title || \'提示框\'\n        title.className = this.data.titleClassName || \'dialog-title\'\n        const defaultStyle = {\n          height: \'25px\',\n          lineHeight: \'25px\',\n          padding: \'10px 0\',\n          border: \'1px solid #e0e0e0\',\n          textAlign: \'center\'\n        }\n        const titleStyle = Object.assign({}, defaultStyle, this.data.titleStyle)\n\n        for (let key in titleStyle) {\n          title.style[key] = titleStyle[key]\n        }\n\n        this.title = title\n      }\n      createBackgroundBox() {\n        const bgBox = document.createElement(\'div\')\n        bgBox.className = this.data.bgBoxClassName || \'dialog-background\'\n        bgBox.id = \'bgBox\'\n        const defaultBgStyle = {\n          position: \'fixed\',\n          top: \'0\',\n          left: \'0\',\n          width: \'100%\',\n          height: \'100vh\',\n          backgroundColor: \'rgba(0,0,0,0.7)\'\n        }\n        const boxBgStyle = Object.assign({}, defaultBgStyle, this.data.boxBgStyle)\n        for (let key in boxBgStyle) {\n          bgBox.style[key] = boxBgStyle[key]\n        }\n        this.bgBox = bgBox\n      }\n      close() {\n        const bgBox = document.getElementById(\'bgBox\')\n        document.body.removeChild(bgBox)\n      }\n      show() {\n        this.init()\n      }\n    }\n</code></pre>\n<p><strong>调用示例</strong></p>\n<pre><code class=\"javascript language-javascript\">const dialog = new Alert({\n  title: \'我是一个消息提示框\',\n  content: \'为ID和class取通用且有意义的名字。非必要的情况下，ID和class的名称应尽量简短\',\n  width: \'500px\',\n  height: \'170px\',\n  confirmClassName: \'confirm\',\n  confirmText: \'好的\',\n  closeText: \'不好\',\n  fail() {\n    console.log(123);\n    dialog.close()\n  }\n})\n\ndialog.show()\n</code></pre>', '这是一个页面常用弹出框提示的class类，使用函数的方法调用，并支持传入确认和关闭的回调函数success、fail以及自定义样式等。\n\n```javascript\nclass Alert {\n      constructor(data) {\n        this.data = data\n      }\n      init() {\n        this.createBackgroundBox()\n        this.initALertParent()\n        this.createBtns()\n        this.createTitleBox()\n        this.initContent()\n        this.mount()\n        this.bindEvent()\n        document.body.appendChild(this.bgBox)\n      }\n      mount() {\n        this.parent.appendChild(this.title)\n        this.parent.appendChild(this.content)\n        this.btnBox.appendChild(this.closeBtn)\n        this.btnBox.appendChild(this.confirmBtn)\n        this.parent.appendChild(this.btnBox)\n        this.bgBox.appendChild(this.parent)\n      }\n      bindEvent() {\n        this.confirmBtn.onclick = this.data.success || this.close\n        this.closeBtn.onclick = this.data.fail || this.close\n      }\n      createBtns() {\n        const btnDiv = document.createElement(\'div\')\n        btnDiv.style.height = \'50px\'\n        btnDiv.style.lineHeight = \'1\'\n        btnDiv.style.display = \'flex\'\n        btnDiv.style.justifyContent = \'center\'\n        btnDiv.style.alignItems = \'center\'\n        btnDiv.style.borderTop = \'1px solid #e0e0e0\'\n\n        const closeBtn = document.createElement(\'a\')\n        closeBtn.innerHTML = this.data.closeText || \'关闭\'\n        closeBtn.className = this.data.closeClassName || \'close-btn\'\n        this.setBtnStyle(closeBtn)\n\n        const confirmBtn = document.createElement(\'a\')\n        confirmBtn.className = this.data.confirmClassName || \'submit-btn\'\n        confirmBtn.innerHTML = this.data.confirmText || \'确认\'\n        this.setBtnStyle(confirmBtn)\n\n        this.closeBtn = closeBtn\n        this.confirmBtn = confirmBtn\n        this.btnBox = btnDiv\n      }\n      setBtnStyle(btn) {\n        btn.style.display = \'inline-block\'\n        btn.style.padding = \'10px\'\n      }\n      initContent() {\n        const content = document.createElement(\'p\')\n        content.innerHTML = this.data.content || \'\'\n        const defaultStyle = {\n          height: `calc(${this.data.height} - 118px)`,\n          textAlign: \'left\',\n          padding: \'10px\',\n          overflow: \'auto\'\n        }\n        const contentStyle = Object.assign({}, defaultStyle, this.data.contentStyle)\n        for (let key in contentStyle) {\n          content.style[key] = contentStyle[key]\n        }\n        content.className = this.data.contentClassName || \'dialog-content\'\n        this.content = content\n      }\n      initALertParent() {\n        const parent = document.createElement(\'div\')\n        const defaultStyle = {\n          position: \'absolute\',\n          top: \'50%\',\n          left: \'50%\',\n          transform: \'translateX(-50%) translateY(-50%)\',\n          width: this.data.width || \'700px\',\n          height: this.data.height || \'400px\',\n          backgroundColor: \'#fff\',\n        }\n\n        const parentStyle = Object.assign({}, defaultStyle, this.data.parentStyle)\n        for (let key in parentStyle) {\n          parent.style[key] = parentStyle[key]\n        }\n\n        this.parent = parent\n      }\n      createTitleBox() {\n        const title = document.createElement(\'div\')\n        title.innerHTML = this.data.title || \'提示框\'\n        title.className = this.data.titleClassName || \'dialog-title\'\n        const defaultStyle = {\n          height: \'25px\',\n          lineHeight: \'25px\',\n          padding: \'10px 0\',\n          border: \'1px solid #e0e0e0\',\n          textAlign: \'center\'\n        }\n        const titleStyle = Object.assign({}, defaultStyle, this.data.titleStyle)\n\n        for (let key in titleStyle) {\n          title.style[key] = titleStyle[key]\n        }\n\n        this.title = title\n      }\n      createBackgroundBox() {\n        const bgBox = document.createElement(\'div\')\n        bgBox.className = this.data.bgBoxClassName || \'dialog-background\'\n        bgBox.id = \'bgBox\'\n        const defaultBgStyle = {\n          position: \'fixed\',\n          top: \'0\',\n          left: \'0\',\n          width: \'100%\',\n          height: \'100vh\',\n          backgroundColor: \'rgba(0,0,0,0.7)\'\n        }\n        const boxBgStyle = Object.assign({}, defaultBgStyle, this.data.boxBgStyle)\n        for (let key in boxBgStyle) {\n          bgBox.style[key] = boxBgStyle[key]\n        }\n        this.bgBox = bgBox\n      }\n      close() {\n        const bgBox = document.getElementById(\'bgBox\')\n        document.body.removeChild(bgBox)\n      }\n      show() {\n        this.init()\n      }\n    }\n```\n\n**调用示例**\n```javascript\nconst dialog = new Alert({\n  title: \'我是一个消息提示框\',\n  content: \'为ID和class取通用且有意义的名字。非必要的情况下，ID和class的名称应尽量简短\',\n  width: \'500px\',\n  height: \'170px\',\n  confirmClassName: \'confirm\',\n  confirmText: \'好的\',\n  closeText: \'不好\',\n  fail() {\n    console.log(123);\n    dialog.close()\n  }\n})\n\ndialog.show()\n```', '3', '1', '1');
COMMIT;

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `articalid` int DEFAULT NULL COMMENT '文章id',
  `commentid` int NOT NULL AUTO_INCREMENT COMMENT '评论id',
  `ctime` varchar(20) DEFAULT NULL COMMENT '评论创建时间',
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '头像地址url',
  `content` varchar(1000) DEFAULT NULL COMMENT '评论内容',
  `name` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT '评论人名称',
  PRIMARY KEY (`commentid`)
) ENGINE=InnoDB AUTO_INCREMENT=22 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of comment
-- ----------------------------
BEGIN;
INSERT INTO `comment` VALUES (1000075, 14, '2021-02-06 21:55:21', 'https://s3.ax1x.com/2020/12/11/rkhp5V.jpg', '这篇文章写的还不错', '我是一直小精灵');
INSERT INTO `comment` VALUES (1000075, 18, '2021-02-06 22:24:02', 'http://42.192.140.201/public/avatar/08.jpg', '这篇文章写的还不错，继续加油', 'Labron James');
INSERT INTO `comment` VALUES (1000069, 19, '2021-02-06 22:25:09', 'http://42.192.140.201/public/avatar/02.jpg', '这个记录不错，继续加油吧！', '小白同学');
INSERT INTO `comment` VALUES (1000026, 20, '2021-02-06 22:25:31', 'http://42.192.140.201/public/avatar/08.jpg', '这篇文章不错，收藏下了！', 'Labron James');
INSERT INTO `comment` VALUES (1000024, 21, '2021-02-07 10:02:42', 'http://42.192.140.201/public/avatar/07.jpeg', 'Vue组件重写', 'James Harden');
COMMIT;

SET FOREIGN_KEY_CHECKS = 1;
